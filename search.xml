<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>两大传奇 宿命对决</title>
    <url>/2023/03/12/%E4%B8%A4%E5%A4%A7%E4%BC%A0%E5%A5%87-%E5%AE%BF%E5%91%BD%E5%AF%B9%E5%86%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=210060285&aid=926327782&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>]]></content>
      <categories>
        <category>b站分享</category>
      </categories>
      <tags>
        <tag>b站分享</tag>
      </tags>
  </entry>
  <entry>
    <title>初识opencv</title>
    <url>/2023/03/03/%E5%88%9D%E8%AF%86opencv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初识opencv"><a href="#初识opencv" class="headerlink" title="初识opencv"></a>初识opencv</h1><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#opencv学习</span>
<span class="token keyword">import</span> cv2
<span class="token keyword">import</span> matplotlib
<span class="token comment">#matplotlib.use('agg')</span>
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'hblgos.jpg'</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>IMREAD_GRAYSCALE<span class="token punctuation">)</span>
<span class="token comment">#print(img)</span>
<span class="token triple-quoted-string string">'''cv2.imshow('picture',img)
cv2.waitKey(0)
cv2.destroyAllWindows()'''</span>
<span class="token triple-quoted-string string">'''cv2.imwrite('first.jpg',img=img)
print(img.shape)'''</span>
<span class="token comment">#poi区域,只捕捉感兴趣的区域</span>
imag<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'hblgos.jpg'</span><span class="token punctuation">)</span>
<span class="token comment">#进行切片获得想要的部分</span>
<span class="token comment">#now=imag[0:50,0:150]</span>
<span class="token comment"># cv2.imshow('roi',now)</span>
<span class="token comment"># cv2.waitKey(0)</span>
<span class="token comment"># cv2.destroyAllWindows()</span>
b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>imag<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
imag<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>imag<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
cp_imag<span class="token operator">=</span>imag<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
cp_imag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
cp_imag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'r'</span><span class="token punctuation">,</span>cp_imag<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>







]]></content>
      <categories>
        <category>数字图像</category>
      </categories>
      <tags>
        <tag>数字图像</tag>
      </tags>
  </entry>
  <entry>
    <title>宋浩</title>
    <url>/2023/03/14/%E5%AE%8B%E6%B5%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="根据北宋哲学家邵雍的计算，世界上的事物将在十二万九千六百年后完全重现，也许，十二万九千六百年后我们还会再见面吧"><a href="#根据北宋哲学家邵雍的计算，世界上的事物将在十二万九千六百年后完全重现，也许，十二万九千六百年后我们还会再见面吧" class="headerlink" title="根据北宋哲学家邵雍的计算，世界上的事物将在十二万九千六百年后完全重现，也许，十二万九千六百年后我们还会再见面吧"></a>根据北宋哲学家邵雍的计算，世界上的事物将在十二万九千六百年后完全重现，也许，十二万九千六百年后我们还会再见面吧</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=884533556&aid=604968078&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>欧文与小卡</title>
    <url>/2023/03/12/%E6%AC%A7%E6%96%87%E4%B8%8E%E5%B0%8F%E5%8D%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=870877950&aid=261951849&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<h2 id="16年骑士"><a href="#16年骑士" class="headerlink" title="16年骑士"></a>16年骑士</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=214711273&aid=371420865&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<h2 id="见证历史"><a href="#见证历史" class="headerlink" title="见证历史"></a>见证历史</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=999135621&aid=609059663&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=978625353&aid=523356651&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<h2 id="湖人真的可能黑八"><a href="#湖人真的可能黑八" class="headerlink" title="湖人真的可能黑八"></a>湖人真的可能黑八</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=1044774290&aid=653139721&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=1048869938&aid=483309722&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>]]></content>
      <categories>
        <category>b站分享</category>
        <category>篮网</category>
      </categories>
      <tags>
        <tag>b站分享</tag>
        <tag>篮网</tag>
      </tags>
  </entry>
  <entry>
    <title>漫威十年</title>
    <url>/2023/03/03/%E6%BC%AB%E5%A8%81%E5%8D%81%E5%B9%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="两个人撑起了漫威十年"><a href="#两个人撑起了漫威十年" class="headerlink" title="两个人撑起了漫威十年"></a>两个人撑起了漫威十年</h1><h1 id="X-man-wolverine"><a href="#X-man-wolverine" class="headerlink" title="X-man wolverine"></a>X-man wolverine</h1><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=141669474&aid=82805456&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<h1 id="Avengers-iron-man"><a href="#Avengers-iron-man" class="headerlink" title="Avengers iron-man"></a>Avengers iron-man</h1><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=134444593&aid=78075979&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>]]></content>
      <categories>
        <category>b站分享</category>
      </categories>
      <tags>
        <tag>b站分享</tag>
      </tags>
  </entry>
  <entry>
    <title>篮网总冠军</title>
    <url>/2023/03/12/%E7%AF%AE%E7%BD%91%E6%80%BB%E5%86%A0%E5%86%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="篮网总冠军"><a href="#篮网总冠军" class="headerlink" title="篮网总冠军"></a>篮网总冠军</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=907962493&aid=263179265&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=957991269&aid=222577189&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>


<h2 id="后来你穿回了35号-我穿回了2号-仿佛711从未出现过一样"><a href="#后来你穿回了35号-我穿回了2号-仿佛711从未出现过一样" class="headerlink" title="后来你穿回了35号 我穿回了2号 仿佛711从未出现过一样"></a>后来你穿回了35号 我穿回了2号 仿佛711从未出现过一样</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=1043442575&aid=865684165&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>]]></content>
      <categories>
        <category>篮网</category>
      </categories>
      <tags>
        <tag>篮网</tag>
      </tags>
  </entry>
  <entry>
    <title>纸人</title>
    <url>/2023/03/03/%E7%BA%B8%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=819375431&aid=430084923&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

]]></content>
      <categories>
        <category>向日葵</category>
      </categories>
      <tags>
        <tag>向日葵</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/2023/03/03/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h1><h2 id="KMeans"><a href="#KMeans" class="headerlink" title="KMeans"></a>KMeans</h2><p>Kmeans算法，也被称为K-平均或K-均值，是一种得到最广泛使用的聚类算法，主要思想是：首先将各个聚类子集内的所有数据样本的均值作为该聚类的代表点，然后把每个数据点划分到最近的类别中，使得评价聚类性能的准则函数达到最优，从而使同一个类中的对象相似度比较高，而不同类之间的对象的相似度较小</p>
<p>算法优点：理论清晰，算法简单，算法收敛速度很快，仅需20次以内的迭代就能得出最终聚类结果，适用于发现球形聚类簇</p>
<p>算法缺点：算法结果依赖初始中心的选取，如果算法初值选取不当，会陷入局部最优解，不能发现非球形聚类簇，不能发现差别很大的类，对噪声和孤立点很敏感</p>
<h2 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h2><p>最大期望算法是在概率模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量。最大期望经常用在机器学习和计算机视觉数据聚类领域，最大期望算法经过两个步骤交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算最大似然估计值，第二步最大化，最大化在计算期望上求得的最大似然值计算参数的值，最大化上找的参数估计值被用于下一个计算期望的步骤中，两个步骤交替进行。</p>
<p>算法优点：最大期望算法计算结构稳定，准确，算法可以给出每一类样本被分配到每一个类的概率，丰富的信息量要比简单的结果好的多，可以把这个结果转化为一个得分，表示模型对结果的把握，最后我们选取把握最大的模型</p>
<p>算法缺点：计算复杂收敛较慢，不适合大规模数据和高维数据，在迭代中如果某类样本特别少会导致协方差矩阵奇异，容易陷入局部最优，对孤立点敏感，有噪音效果差</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫学习</tag>
      </tags>
  </entry>
  <entry>
    <title>考研每周复盘</title>
    <url>/2023/04/04/%E8%80%83%E7%A0%94%E6%AF%8F%E5%91%A8%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="上岸了"><a href="#上岸了" class="headerlink" title="上岸了"></a>上岸了</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=570229691&aid=767887804&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>


<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="考研期间受到一位北邮大佬启发开始做每周复盘，最后坚持了300多天，每个人的进度都不一样，不喜勿喷，后面准备了自己在考研期间做的导图和部分资料，希望能帮助更多的人上岸。"><a href="#考研期间受到一位北邮大佬启发开始做每周复盘，最后坚持了300多天，每个人的进度都不一样，不喜勿喷，后面准备了自己在考研期间做的导图和部分资料，希望能帮助更多的人上岸。" class="headerlink" title="考研期间受到一位北邮大佬启发开始做每周复盘，最后坚持了300多天，每个人的进度都不一样，不喜勿喷，后面准备了自己在考研期间做的导图和部分资料，希望能帮助更多的人上岸。"></a>考研期间受到一位北邮大佬启发开始做每周复盘，最后坚持了300多天，每个人的进度都不一样，不喜勿喷，后面准备了自己在考研期间做的导图和部分资料，希望能帮助更多的人上岸。</h2><h2 id="考研每周复盘"><a href="#考研每周复盘" class="headerlink" title="考研每周复盘"></a>考研每周复盘</h2><h3 id="考研第一周（12月27日———1月1日，在家复习）"><a href="#考研第一周（12月27日———1月1日，在家复习）" class="headerlink" title="考研第一周（12月27日———1月1日，在家复习）"></a>考研第一周（12月27日———1月1日，在家复习）</h3><p>英语：</p>
<p>状态并不是很好，但是渐渐的适应了，碎片时间可以背单词，尽量多找时间背，最后周末总复习（利用默写本）</p>
<ol>
<li><p>考研词汇闪过wordlist1，但是速度太慢，后期需要提高速度。</p>
<p>然后每个周末进行一次复习，利用默写本，将单词多写几遍，同时对单词的词性加深理解。</p>
</li>
<li><p>看了唐叔的长难句逻辑，主要用在翻译题上，主要分为3个部分，抓句子主干，非主干的句子与主句之间的关系，that并列，逗号的使用，长难句可以通过每周的外刊和收藏的每日一句来练手</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*长难句逻辑1，主要讲述提取主干，几个关键点，
连词，and,or,but,yet,分析前后的连接成分，从后往前看，两边成分必须相同，都是词或都是句子；特殊疑问词做连词；连词和谓语动词之间个数n:n+1
&#x2F;*长难句逻辑2，主要讲述分析句子中的非主干从句
破解点，就是逗号，逗号连接的大部分时从句个句子主干的一部分，共有7种结构;that宾语从句和同位语从句以从句成分是否完整区分
&#x2F;长难句逻辑3，多个that引导从句并列，分清是什么成分，各个从句之间的关系（并列从句，套从句），和句子主干成分之间的关系；that引导定语从句时，学会找出被修饰的名词或短语，没有就近原则。</code></pre>
</li>
<li><p>看了基础阅读的前5个视频，回学校后还需要重刷</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*基础阅读部分主要有几个阅读题经典的体型*&#x2F;&#x2F;&#x2F;！！！阅读题是对比出来的，经常出现替换，推理过火，或者长难句难以理解，还有例子题，观点
&#x2F;*做阅读题的基本步骤，先看问题，但是不看选项，通过问题之前的公共部分，推断出文章的大部分篇幅，*&#x2F;
&#x2F;*阅读1
重视连词，连词反映句子之间的关系，因果，并列等，段落之间的逻辑，要谨慎理解，找出承上启下的句子（难题常考），
&#x2F;*阅读2
各种符号的使用，极其重要：，“”(经常考)，
&#x2F;*阅读3
例证题，要看例子，但是例子里的句子一般先排除，因为例证题，大部分时问观点，观点一般在例子前或者例子后（作者观点很重要，可结合承上启下的句子判断）
&#x2F;*阅读4
作者观点题，情态动词，should(与原文意思相反，作者有可能在大篇幅举反例，正确观点只在细小的地方)
&#x2F;*阅读5
中心思想题。强干扰项，一定要一个一个单词去比对，删除共有部分，看那个篇幅长，有可能是中心思想。</code></pre>
</li>
<li><p>看了考研真相的基础研读版，主要是一些之前学生阶段学到过的语法，还没有看完，打算回学校再看。</p>
</li>
</ol>
<p>数学：</p>
<p>状态进入的并不是很快，但是逐渐摸索到自己的节奏，不要心急，有时间，660的题比较难，但是比较有参考价值，做完一个题一定要理解，此外从第二周开始，数学的基础班看一个视频，宋浩的线代基础课尽量三周之内结束，看汤家凤的零基础概率课（教材）和余炳森的基础班（余炳森概率书），尽量做教材上的题，记笔记和错题本，每周一复盘。</p>
<ol>
<li>看了视频，还是没有看完，前三章的内容比较多，而且是重点，还是要多看看，第一章还剩下两个视频，下一周把视频看完，同时做第一章的880</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;看了几个视频，但是第一章的基础班还没有看完，尽量在下一周结束
&#x2F;*12月27日，看的第P2，主要讲的是数列的极限和函数的极限
有界收敛，无界发散，位置图形记忆，关系，正反记忆
保号性，横坐标轴记忆
给递推关系求数列极限，极限设a,利用递推关系求a,没有在660上实践，导致题目做错
&#x2F;*12月29日，看的P3，主要讲的是无穷小量和无穷大量的性质（对积没有限制，与有界变量正反记忆），
无穷大和无界变量的性质（便于理解，处处无穷大，无界只要求有一个点无穷大，判断无界看是否有的点极限是0，有的点极限无穷大）
三步走战略1的无穷和1的无穷-1，
极限存在才可以分开先算，先算出的极限必须是定值，660第4题</code></pre>

<ol start="2">
<li>复盘了武忠祥的每日一题，复盘记录在桌面上另一个文件</li>
<li>660复盘,在另一个桌面文件</li>
</ol>
<h3 id="考研第二周（1月3日———–1月8日，在家复习）"><a href="#考研第二周（1月3日———–1月8日，在家复习）" class="headerlink" title="考研第二周（1月3日———–1月8日，在家复习）"></a>考研第二周（1月3日———–1月8日，在家复习）</h3><p>英语：</p>
<p>使用词汇闪过，和墨墨背单词，背诵效率很高，坚持看长难句，和词汇</p>
<p>数学：</p>
<p>武忠祥，第一章复习完成，同时完成了1800，660，和880，但是1800因为去参加婚礼耽误了，还是要尽快补上。</p>
<h3 id="考研第三周（1-10-1-16，在家复习）"><a href="#考研第三周（1-10-1-16，在家复习）" class="headerlink" title="考研第三周（1.10-1.16，在家复习）"></a>考研第三周（1.10-1.16，在家复习）</h3><p>英语：</p>
<p>继续背单词，坚持考研英语外刊，长难句</p>
<p>数学：</p>
<p>武忠祥，完成第二章的复习，还没有写880，1800</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;基础篇
&#x2F;*第一章
	例14.极限的定义
	例15.数列极限的定义
	例16.无穷大和无界题，经典反例[1&#x2F;x]·sin(1&#x2F;x),x&#x3D;1&#x2F;[2n*pi]
	例17.经典错误，【n的n次方】&#x2F;【[n+1]的n次方】，n-&gt;无穷，不等于1，原因是因为，n不是定值
	例26.分子极限0，代入直接是极限0，就不能，分子极限&#x3D;0来算
	例31，洛必达，学会构造分母
	※例33，n阶可导与n阶连续可导
	例35，学会使用泰勒
	例36.使用泰勒，分子上非公因子，无穷小代换的精度
	例37，夹逼，一般只动分母
	例41.经典题型
	例47，e的某次方，提公因子，不要加一减一（太危险）
	第三节
	例4.构造洛必达
	例9.讨论连续性，找间断点，分段
	例10.闭区间连续
*&#x2F;
&#x2F;*第二章
	例2，导数的两种定义，一种不行，构造另一种
	经典迷惑，可导有切线，有切线，不一定可导（x的1&#x2F;3次方）
	经典迷惑，连续不一定可导的例子（x&#x3D;0,y&#x3D;0,其余y&#x3D;x*xsin(1&#x2F;x)）
	例5
	例7，例8，奇偶，周期函数的导函数（计算快）
	※例20，不存在+不存在&#x3D;&#x3D;不一定 经典反例|x|，导数两边极限都存在，导数也不一定存在
	例28.极坐标求导
	例29.导数实际应用，相关变换率
*&#x2F;</code></pre>

<h3 id="考研第四周（1-17———-1-22）"><a href="#考研第四周（1-17———-1-22）" class="headerlink" title="考研第四周（1.17———-1.22）"></a>考研第四周（1.17———-1.22）</h3><p>复试的要准备的课程和技巧视频都整理的差不多了，从这一周开始，主要看数学和英语，从下一周开始，争取，高数，线代，概率都能学完一章，并把习题（660（根据题目知识点）880，1800）做完，回学校后，开始问师姐专业课整理资料，开始专业课</p>
<p>英语：</p>
<pre><code>坚持背单词，唐叔的长难句，还有外刊阅读，金榜的每日一句
</code></pre>
<p>数学：</p>
<pre><code>增添了很多新栏目，汤家凤的每日一题，公众号也多了起来，好好利用
</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*视频课，错题本，笔记总结
第三章
	例7.应用题，，列出函数时，尽量要简便
	一种题型，断点处的导数值，前提，先验证函数是否连续，再去看导数值存不存在，再去求
	例11.求渐近线，e的x,arctan，正负无穷分开讨论，880，1800，均有
	求渐近线，武的方式
	例17，不等式证明，学会放缩
	例19，例20，构造特殊点，使用拉格朗日中值定理和罗尔定理，880上大量出现
	例21，连续函数界值定理
	构造函数，根据导导数一方，前面有x的n次方，说明原函数有可能有x的n次方，没有，只有数的话，原函数可能有e的x次方
*&#x2F;</code></pre>

<h3 id="考研第五·第六周（1-23——-2-6，1-28发烧，输液三天，2-1过年，2-6正月初六开始）"><a href="#考研第五·第六周（1-23——-2-6，1-28发烧，输液三天，2-1过年，2-6正月初六开始）" class="headerlink" title="考研第五·第六周（1.23——-2.6，1.28发烧，输液三天，2.1过年，2.6正月初六开始）"></a>考研第五·第六周（1.23——-2.6，1.28发烧，输液三天，2.1过年，2.6正月初六开始）</h3><p>英语：</p>
<pre><code>坚持背单词，唐叔的长难句，还有外刊阅读，金榜的每日一句
</code></pre>
<p>数学</p>
<p>概率：</p>
<p>零基础简单的理论</p>
<p>高数：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;第四章
&#x2F;*
	原函数存在定理，连续，第二类间断点有原函数
		例1（3）
		例19，分段函数连续
	不定积分公式，每个三角函数的原函数
	各种换元
		例6
		例13，14，15，16，先三角有理化，再根据正负号-x换元
		例18
	各种凑微分
		例3（4），例10
		例12，多重多次分母和分子
	各种拆项
		例2（2）
	各种有理化（含有根式，三角函数）
		例2（3）
	各种分部积分
		例7（2）（4），分部有循环
		例8，例9
		例24
	积分定义
		例25，例26
*&#x2F;</code></pre>

<h3 id="考研第七周（2-7————–2-13）"><a href="#考研第七周（2-7————–2-13）" class="headerlink" title="考研第七周（2.7————–2.13）"></a>考研第七周（2.7————–2.13）</h3><p>英语：坚持背单词，单词量已经准备好了，回学校，复习唐叔的长难句和阅读的逻辑，然后刷真题</p>
<p>专业课：准备好教材和辅导书，以及上课视频，回学校开始复习</p>
<p>数学:数学加了零基础这一门，尽量在3月底结束零基础，然后4-5月数学基础篇完成</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*
这一周的状态并不是很好，心老是静不下来，尽量提高学习效率
复习了高数，概率，线代，但是下一周必须提上速度和进程，开学的时间还没定，时间不能浪费
同时，抓紧复习660，880，1800，还有高数基础篇上的例题
*&#x2F;</code></pre>

<h3 id="考研第八周–第九周（2-14—–2-27）"><a href="#考研第八周–第九周（2-14—–2-27）" class="headerlink" title="考研第八周–第九周（2.14—–2.27）"></a>考研第八周–第九周（2.14—–2.27）</h3><p>英语：看完了唐迟的基础阅读，细节题，例证题，推断题，态度题，中心思想题，词汇题几种，还是要看pdf,坚持背单词，下周背完闪过的高中低频词，看完考研真相基础研读版，使用长难句闪过（张真静团队）</p>
<p>专业课：下周开始</p>
<p>数学，零基础和基础篇的一章要连着看，否则没有很多时间，坚持刷题，找回做题的手感。</p>
<h3 id="考研第十周（2-28———-3-6）（开始在校复习）"><a href="#考研第十周（2-28———-3-6）（开始在校复习）" class="headerlink" title="考研第十周（2.28———-3.6）（开始在校复习）"></a>考研第十周（2.28———-3.6）（开始在校复习）</h3><p>英语：闪过的高中低频词刷完一遍，已经开始二刷，开始背偶考词，听斌斌老师的长难句学语法，看阅读真题词汇</p>
<p>专业课：听了王道的直播，3.7开始直播，数据结构（两周后）计算机网络——计算机原理—-操作系统</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*408复习战略
80分选择，70分大题
基础阶段搞定小题
强化阶段大题（暑期强化课）
冲刺阶段套题
*&#x2F;</code></pre>



<p>数学：先准备高数和线代，打算5月初开始准备概率</p>
<pre><code>高数：
</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;学习了第十一章和第五章
&#x2F;*第十一章向量代数几何与空间解析集合（多元函数微分学还没有看）
混合积，考的很少，具有轮换对称性和交换变号，三向量共面，混合积为0
曲面，柱面，旋转面------&gt;二次型曲面，圆锥面，椭圆锥面，球面，椭球面，旋转抛物面
				缩放
*&#x2F;
&#x2F;*第五章定积分与反常积分
定积分存在三定理
积分中值定理，f(x)g(x),g(x)区间不变号。
积分函数奇偶性，奇函数严格，偶函数没有要求
定积分两个公式
	例6.几何意义，面积比较，梯形面积
	例8.放缩
	例13.对称性
	例17.分部积分与变限积分
	例23。原函数连续和可导的判断
	例25，积分中值定理与极限结合（极限经常和第二个积分中值定理一起考）
*&#x2F;</code></pre>

<pre><code>线代:跟李永乐学习了行列式，下周打算学习矩阵
</code></pre>
<h3 id="考研第十一周（3-7—3-13）"><a href="#考研第十一周（3-7—3-13）" class="headerlink" title="考研第十一周（3.7—3.13）"></a>考研第十一周（3.7—3.13）</h3><p>英语:</p>
<pre><code>高中低频词二刷完毕，争取这个月背完闪过，同时完成长难句精讲，3月底开始刷题
</code></pre>
<p>专业课：</p>
<pre><code>数据结构完成第一章绪论，课后题做的不是很好，许多概念都没有搞清，还是要坚持，遇见错题可以去牛客网上问
</code></pre>
<p>数学：</p>
<p>完成了矩阵的学习，完成了矩阵章的880 ，1800，660暂时搁置，复习概率时刷保持做题的感觉</p>
<p>高数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;反常积分和定积分的应用
&#x2F;*反常积分
反常积分的由来主要是为了解决无穷区间和无穷函数的积分，定积分是无法解决这两个方面的问题的
	无穷区间上的积分
		判断收敛性：定义，x的p次方，比较法（比较法，先要做的是要放缩，往收敛放还是发散放，主要开分子分母指数差，根据是否大于			1，根据x的p次方去放）
	无界函数的反常积分
    	找到无界点，无界点在中间就分段
    	判断收敛性：还是相同方法，这里的比较法，跟谁比主要取决于无界点是谁-----------例2，例6
    	例5，ex讨论无穷分开讨论
*&#x2F;
&#x2F;*定积分的应用
	几何应用
		面积，xy,p(θ),笼统公式，是二重积分
		体积 xy	笼统公式，二重积分
		弧长 xy,p(θ)，参数
		旋转体侧面积 xy	长是2pif(x),宽是弧长
	物理应用：
		做功
		压力
*&#x2F;</code></pre>

<h3 id="考研第十二周（3-14————–3-21肚子着凉，进度有些慢）"><a href="#考研第十二周（3-14————–3-21肚子着凉，进度有些慢）" class="headerlink" title="考研第十二周（3.14————–3.21肚子着凉，进度有些慢）"></a>考研第十二周（3.14————–3.21肚子着凉，进度有些慢）</h3><p>英语：闪过单词过了一遍，同时高中低频已经完成第三遍复习，下一周打算，在复习一遍高中低频词，同时，将偶考词和简单词再复习一遍，同时复习唐迟的基础阅读课，看利之学姐的笔记，看一下考研真相，单词任务完成后开始刷考研真相。</p>
<p>专业课：复习完第二章线性表，每一个顺序表和链表的算法，都要在计算机上实现一遍。</p>
<p>数学：完成了880和1800的向量代数几何和定积分应用，定积分的证明题，比较难，二刷时，要多注意，下周争取复习完微分方程，4月分看完线代和高数下的多元函数积分和积分，5月份完成概率和级数。</p>
<h3 id="考研第十三周（3-22————–3-27）"><a href="#考研第十三周（3-22————–3-27）" class="headerlink" title="考研第十三周（3.22————–3.27）"></a>考研第十三周（3.22————–3.27）</h3><p>英语：闪过高中低频第四遍完毕，开始写一些难写的词，偶考词复习完一轮，接着滚动复习，斌斌老师的阅读理论课，精准定位，前提法，比出最佳选项</p>
<p>专业课，复习完栈队列数组，下周找时间复习一下C++的算法库和stl库，这样一些基本操作就很容易解决</p>
<p>数学：完成了微分方程，1800，880完成，下周先复习线代，同时，对高数上来个复习</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*微分方程
	例17，x,y倒置
	例21，23二阶常系数非齐次解的问题，880，1800，看给一个解还是多个解，xex一定是非齐次的解
	例26，导数定义构造微分方程。
*&#x2F;</code></pre>

<h3 id="考研第十四周（3-28——-4-2）"><a href="#考研第十四周（3-28——-4-2）" class="headerlink" title="考研第十四周（3.28——-4.2）"></a>考研第十四周（3.28——-4.2）</h3><p>英语：练习比较难写的高中低频词，简单词和补充词马上复习完第二遍，争取下周看完斌斌老师的阅读理论课，开始拿英二的真题来练手。</p>
<p>专业课：串复习完，比较少,kmp算法，暴力匹配算法，都有难点，一个是i指针回退位置,一个是next数组和nextval数组的手算</p>
<p>数学：把积攒的660刷完，跟着咋子哥刷题很快，很高效，复习完线代的向量，准备在复习高数时，刷线代，复习线代时刷高数，保持做题的手感。</p>
<h3 id="考研第十五周（4-2———-4-7）"><a href="#考研第十五周（4-2———-4-7）" class="headerlink" title="考研第十五周（4.2———-4.7）"></a>考研第十五周（4.2———-4.7）</h3><p>英语：阅读理论课刷完，也刷了一篇阅读，坚持看外刊，积累单词</p>
<p>数学：完成了多元函数的660和1800，下周打算完成880和线代</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*多元函数微分学
	二重极限的存在问题，学会放缩
	全微分存在条件
	例5，大积分的问题和大积分与偏导的问题不是同一个问题
	例7，偏导数确定增减方向
	全微分
		线代后求
		复合函数高阶导
	多元函数极值
		偏积分求原函数
		条件最值
	*&#x2F;</code></pre>

<p>专业课：复习完树，树的内容比较多，也比较重要，应该多花点时间。</p>
<h3 id="考研第十六周（4-9——-4-17）"><a href="#考研第十六周（4-9——-4-17）" class="headerlink" title="考研第十六周（4.9——-4.17）"></a>考研第十六周（4.9——-4.17）</h3><p>英语：刷了5篇阅读，思维渐渐熟练，一天一篇</p>
<p>数学：学完了线代线性方程组，完成了1800和880，1800错的有点多，这一章多加注意，宋浩学完了二重积分，下周争取结束二重积分。</p>
<p>专业课：因为各种报告和上机，进度被耽误了图没有学完，尽量在下周结束，学完图之后，开始复习大数据，计网，软工准备期末考试，同时开始刷力扣，把力扣上的题放到自己的编译器上运行，有助于了解数据结构的基本知识。</p>
<h3 id="考研第十七周-4-18———4-24"><a href="#考研第十七周-4-18———4-24" class="headerlink" title="考研第十七周(4.18———4.24)"></a>考研第十七周(4.18———4.24)</h3><p>英语：还是坚持背单词，刷阅读，每周要对刷过的阅读题，进行回顾，知道自己为什么错</p>
<p>数学：这周因为上机比较多，事也比较多，只把武的二重积分和三重积分的一点内容看完，但是做题比较少，只完成了660和1800的一小部分，进度比较慢，刷了部分的历年真题，但是年代比较久远的还是比较简单，帮助不是很大，所以，每天这个真题的刷题，放在最后。同时从下周开始抽时间学习心一学长的易错题解析</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*二重积分
	积分区域的对称性，看横跨那个对称轴，还有关于y&#x3D;x的对称
	二重积分最重要的一步就是画出积分区域
	例4，积分不好算，更改积分区域
	例7，积分区域不规则，可以进行划分，划分成规则区域
*&#x2F;
&#x2F;*学了部分多重积分的应用
	三重积分直角坐标下两种计算方法。两种切法，
		平行z轴切，最后剩下x,y，或者理解为柱质量之和-----------，找出xoy面的投影，最后求二重积分
		垂直z轴切，最后剩下z,或者理解为面质量之和--------------用z来表示截面的面积，最后求一重积分适合，面积好求，f(z),z看成常数
	柱面坐标
	球面坐标
		三重积分的微元，宋浩画图法
	三重积分对称性，关于，卦限对称
	例1，还是要看区域跨那个轴
	对称性是相对与区域
    
*&#x2F;</code></pre>

<p>专业课：坚持刷力扣，每次接触一个新的ADT时还是会陌生，但是要多刷题，这周事比较多，还是坚持把图看完了，但是效果并不是很好，错的选择题比较多，图的这一章概念题真的很多，还是要多看，下周开始计算机网络，准备期末，但是力扣还是要坚持刷</p>
<h3 id="第十八周（4-25—–4-30）"><a href="#第十八周（4-25—–4-30）" class="headerlink" title="第十八周（4.25—–4.30）"></a>第十八周（4.25—–4.30）</h3><p>英语：坚持刷阅读，后面坚持把monkey的百句实战看完</p>
<p>数学：学习了线代的特征值和特征向量，完成了1800，880，同时完成了多重积分的相关题目</p>
<p>专业课:第一章刚学完，网络层的概念比多，多看几遍</p>
<h3 id="第十九周（5-1———5-8）"><a href="#第十九周（5-1———5-8）" class="headerlink" title="第十九周（5.1———5.8）"></a>第十九周（5.1———5.8）</h3><p>英语：坚持刷阅读，背单词，看长难句</p>
<p>数学：学习了曲线积分，曲面积分，以及多元积分的应用,完成了小部分的1800，争取下周完成线代和1800，880相关题目，结束线代</p>
<p>专业课：计算机网络，完成了物理层，数据链路层开了一点，但是要坚持看，争取下周看完数据链路层和网络层的一半</p>
<h3 id="第二十周（5-9—–5-14）"><a href="#第二十周（5-9—–5-14）" class="headerlink" title="第二十周（5.9—–5.14）"></a>第二十周（5.9—–5.14）</h3><p>英语：坚持刷阅读，背单词，看长难句</p>
<p>数学：线性代数一轮完成，完成了880和1800，高数的880和1800也完成了，下周考试就多了，但是争取能够结束级数</p>
<p>专业课：学习完数据链路层，下周打算学完网络层</p>
<h3 id="第二十一周-5-15———5-21"><a href="#第二十一周-5-15———5-21" class="headerlink" title="第二十一周(5.15———5.21)"></a>第二十一周(5.15———5.21)</h3><p>英语：刷完2016年阅读，text3,真的难，坚持背单词，每天必须复习高中低频词</p>
<p>数学：高数视频课完成，但是由于准备考试，做题时间减少，只完成了部分的1800</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*级数
	常数项级数，新大纲要求的积分判别法
	例4，收敛域和收敛半径
	傅里叶级数公式
*&#x2F;</code></pre>



<p>专业课：完成网络层，继续学习传输层</p>
<h3 id="第二十二周（5-22——-5-28）"><a href="#第二十二周（5-22——-5-28）" class="headerlink" title="第二十二周（5.22——-5.28）"></a>第二十二周（5.22——-5.28）</h3><p>英语：完成2006年真题</p>
<p>数学：高数一轮完成，完成了线代的行列式强化</p>
<p>专业课：计网一轮完成</p>
<p>这周也在准备期末，进度稍微有点慢，现在期末结束了，该把效率提上去了</p>
<h3 id="第二十三周（5-29———-6-3）"><a href="#第二十三周（5-29———-6-3）" class="headerlink" title="第二十三周（5.29———-6.3）"></a>第二十三周（5.29———-6.3）</h3><p>英语：这周准备六级，重点是把阅读和段落匹配的分拿到，英一的题和六级的题交互着做，保持手感，段落匹配题每天坚持做，就是在长难句翻译</p>
<p>数学：高数强化第一章完成，武的强化第一章的视频课比较长，所以比较耗时间，所以这周做的题比较少</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*强化第一章函数，极限，连续
	*变上限积分函数和原函数以及奇偶性的关系，变上限积分函数意味着函数可积，函数可积的条件是连续，或者有跳跃
									  						    原函数存在的条件连续，或者有第二类
									  						    条件都是连续的时候，两者相同
	*周期函数的推论，前提条件是，函数连续，所以变上限积分函数和原函数就不做区分，如果函数在一个周期的积分是0，那么它的变上限积分函数（原函数）就是周期函数，且周期相同，证明过程F(X+T)，积分分区间拆开，证明周期积分是0，经常和奇函数，然后区间变换成对称区间证明
	*有界函数的推论，如果函数的导数在有限区间上是有界的，那么这个函数在这个有限区间上也是有界的
		证明：微分中值定理，移项，f(x)放在，两边取绝对值，然后使用绝对值不等式
	*a(x)b(x)-&gt;0,三步走战略
	*推论xlnx-&gt;0,x的a次*lnx的b次，只要a&gt;0,就一定趋于0
	*数列极限的求法，加法。夹逼，定积分定义，看书变化部分和不变部分，级数和函数
				  乘法：夹逼，转换为加法
	*数列极限证明，单调有界，不单调，使用两种压缩因子，一种先设极限，另一种不先设极限
				是否单调，后一项减前一项，或者递推关系式求导
				证明单调有界，可以有上届也可以有下届，可以采用，|x|来证明
	*求参数，求出一个，必须待会重现求，因为是根据不定时求出的另一个
	*凯哥二元极限是否连续，x-&gt;0,y-&gt;0,y&#x3D;-x+···，x-&gt;0+,y-&gt;0+,转化极坐标，偶数推论
	*无穷小的阶数比较，变上限积分函数推论，可以自己推
p6题型二
	例1,函数有界的推论，初等函数的无穷比较
	例3，经典f(x)&#39;&gt;0,小于0与增减性的关系，只能证明在这个区间内的值比这个点的函数值大或小，但是无法证明，都大的那部分的增减性
	p9补充答题，p3推导到二阶，一阶导就是连续的，就不会出现，微笑区间震荡，所以f(x)&#39;&gt;0,就单增，f(x)&#39;&#39;的正负与凹凸性的关系与p3在邻域的关系相同
	*补充题，数列极限，确保无穷区间，数列是有界的，而剩余的有限区间，一定是有界的，所以数列极限存在，一定有界
	*保号性A,与f(x)的关系，
	*根据保号性可以退出保序性，比较两个函数的大小
	*p12例1，an的极限和|an|的关系，an的极限a,则|an|的极限|a|,证明过程：极限定义，使用三角绝对值不等式，反之不成立，因为是针																	对不等式推导出来的，不等式只能证明一个方向。
							   an的极限为0与|an|的极限是0互为充要关系，证明：极限的定义，因为是根据等式推导出的
	*p14例4，数列极限，两个数列无界，必有一个数列无界
	*p14例6，重要不等式的推导，
	*p16,等价无穷小洛必达的反推，积分比积分，同理被积分函数就可以替换，前提时被积分函数在积分区间内趋于无穷小
	*5.31补充题，分子上积分中值定理，分母上积分第一中值定理
	*p25,例1精确度的问题，例2提根号下x,
	*p26例4，e与（1+x）**1&#x2F;x放在一起，一定提e，然后再去算
	*p28,凑极限
	p30例无穷的0次，0的0使用,eln,
	p32,例4，夹逼定理和放缩
	p34,乘法的放缩
	p45例1，连续-》有定义确定范围
	
*&#x2F;</code></pre>

<p>专业课，争取这周把查找这一章看完。</p>
<h3 id="第二十四周（6-4—-6-8）（暑假在家复习，在自习室复习）"><a href="#第二十四周（6-4—-6-8）（暑假在家复习，在自习室复习）" class="headerlink" title="第二十四周（6.4—-6.8）（暑假在家复习，在自习室复习）"></a>第二十四周（6.4—-6.8）（暑假在家复习，在自习室复习）</h3><p>英语：继续背单词，刷阅读，争取7.10之前将17年之前的阅读刷完，然后后面直接刷英一的新题型，完型其他题</p>
<p>数学：完成了1800，880，660二刷，新题做了严选题，660，880，历年真题的线代刷完，坚持二刷</p>
<p>专业课：查找复习完，看情况是否复习排序，下周先把广义表看了</p>
<h3 id="这周回家了，希望暑假能结束高数的强化（除了级数），线代和概率的强化，数据结构能再过完一轮，英语能把阅读二刷，同时开始学习小作文如何写，政治打算在7月底开始"><a href="#这周回家了，希望暑假能结束高数的强化（除了级数），线代和概率的强化，数据结构能再过完一轮，英语能把阅读二刷，同时开始学习小作文如何写，政治打算在7月底开始" class="headerlink" title="这周回家了，希望暑假能结束高数的强化（除了级数），线代和概率的强化，数据结构能再过完一轮，英语能把阅读二刷，同时开始学习小作文如何写，政治打算在7月底开始"></a>这周回家了，希望暑假能结束高数的强化（除了级数），线代和概率的强化，数据结构能再过完一轮，英语能把阅读二刷，同时开始学习小作文如何写，政治打算在7月底开始</h3><h3 id="第二十五周（6-9———6-14）"><a href="#第二十五周（6-9———6-14）" class="headerlink" title="第二十五周（6.9———6.14）"></a>第二十五周（6.9———6.14）</h3><p>英语：英语六级，这次感觉考的还行，应该可以过了，刷完2007年阅读，还是二选一，如果都沾点边，就用主旨</p>
<p>数学：准备回家，所以只完成了800函数极限连续的综合篇，后面还是要坚持</p>
<p>专业课：这周没有准备专业课，排序的内容还是比较少的，学完后抓紧再来一遍，之前的知识忘得差不多了，画思维导图。</p>
<h3 id="第二十六周（6-15———6-20）"><a href="#第二十六周（6-15———6-20）" class="headerlink" title="第二十六周（6.15———6.20）"></a>第二十六周（6.15———6.20）</h3><p>英语：完成2008年阅读和2009年阅读第一篇，后期斌斌老师会把更对的阅读结构穿插进来，做好笔记</p>
<p>数学，完成了线代矩阵这一章，概率论开始复习，完成了第一章，题目暂时先做讲义上的题，660和880暂时先不做，概率论先暂时不要刷大量的题，弄懂是最重要的，余炳森讲的挺好，比较容易接受</p>
<p>专业课，确定目标院校，买了复习资料，这周看完了内部排序，下周把外部排序和广义表看完，开始大规模刷题总结</p>
<p>政治的话打算，到概率论的基础篇过完，开始复习，大概在7月下旬，8月初</p>
<h3 id="第二十七周（6-21—-6-25）"><a href="#第二十七周（6-21—-6-25）" class="headerlink" title="第二十七周（6.21—-6.25）"></a>第二十七周（6.21—-6.25）</h3><p>英语：完成了2009年和2010年的阅读第一篇，发现比较难的是主旨题，还是在这种题型上多下功夫，另外，精翻文章时，一定使用斌斌老师长难句的方法，每日一句和外刊可以当作词汇积累</p>
<p>数学：听完一元函数微分学的课还没有做题，前三章的课时，题量都非常大，所以一定要坚持住。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*一元函数微分学
一元函数中可导，可微，连续中的反例|x|,|x|连续不可导
函数处处可导，表达的是在邻域中可导，不能确定x-&gt;x0时导数是否存在，是否连续
导数，h,定义，
p58，例5，函数可导与函数的绝对值可导之间的关系
	函数&#x3D;0，函数导&#x3D;0，所以绝对值可导
	函数不&#x3D;0，函数可导，则绝对值可导，函数不可导，则绝对值不可导
p59,例7，证导函数连续，间断点使用定义，非间断点，直接求导然后取极限
复合函数的导数
	两个都存则存，其余不确定
	p62，例4，遇见sin1&#x2F;x做🔺x时，肯定错误，因为sin1&#x2F;x会等于0
隐函数求导的前提是上一阶的函数值必须知道
参数方程求导，参数方程求高阶导时直接使用公式，因为向直角坐标系下不好转化
反函数求高阶导，依旧是抽象，还是使用公式，再代入
求高阶导
	归纳法
	求特定值时，使用级数和泰勒对应相等
极值的第三推论，助记，泰勒助记，
拐点的第三推论，极值第三推论上升一阶就行
闭区间唯一极值点是最值
渐近线
	常规方法
	武：题x,x-&gt;无穷，就变成了1&#x2F;x-&gt;0,然后就有无穷小
罗尔定理
	推论，n阶导不为0，就至多有n个零点，反正法，设有n+1个零点
p77例4，罗尔定理的推广可以确定零点的上界
p78例8，单调性和罗尔定理的推广，确定零点的上界
		零点定理，确定零点的下界
函数不等式证明
★，微分中值定理的证明（心一学长+武yyds）
	四种常见的高阶00导函数
	一阶一中值
		先标准化，右边必须为0，
		观察法
		解微分方程，最后表示C,C就是辅助函数
	二阶一中值
		先标准化，右边必须为0，
		观察法
		解微分方程，写出特解，然后留C1在右边，然后求导，消去C1，然后再表示C2，C2就是辅助函数
p85注3，写出辅助函数，还会观察，再写出一层辅助函数，遇见变上限和函数，也是解微分方程，变上限用大写字母表示
	一阶二中值
		中值不要求相等
			出现ab,拉格加柯西，拉格加泰勒，可以将还有f,写成f(b)-f(a),然后另一边分子分母都有另一个中值，柯				西，其余再构造辅助函数拉格
			没有出现ab,双拉格，还需要再构造辅助函数
		中值要求不相等
			分区间
			双拉格
			带结论
			加法，双分数线
			乘法，凑，零点定理证明存在
p89注1，2
	高阶中值，
		泰勒
			x：端点，中点（抽象）
			x0,导数点，终点（题干信息多的点）
*&#x2F;</code></pre>

<p>概率论，今天之后大概能结束第三章，概率论知识太散，还是要列导图</p>
<p>专业课：结束了王道数据结构第一轮。</p>
<h3 id="第二十八周-6-26———7-2"><a href="#第二十八周-6-26———7-2" class="headerlink" title="第二十八周(6.26———7.2)"></a>第二十八周(6.26———7.2)</h3><p>数学：完成了第二章一元函数微分学的题，1800二刷，660，880，严选题</p>
<pre><code>        概率论的基础结束，后面开始强化和刷题

        这一周真正意义上的数一的基础篇复习结束
</code></pre>
<p>英语：完成了2010年的阅读，这一年很难，下周听一下猴哥的主旨题，难题就在主旨题</p>
<p>专业课：这周没有开始学专业课，打算下周开始。</p>
<h3 id="第二十九周（7-3——-7-7）"><a href="#第二十九周（7-3——-7-7）" class="headerlink" title="第二十九周（7.3——-7.7）"></a>第二十九周（7.3——-7.7）</h3><p>数学：完成了线代的向量一章,概率论的两章</p>
<p>英语，完成了2011年和2012年的前两篇，总体来说难度还是比较大，要学会有自己的方法和体系，结合斌斌老师的做法</p>
<p>专业课:已经开始了线性表，现阶段刷王道所有的题和天勤上的小题和买的课后题，还是等概率强化阶段结束，开始在下午复习，晚上复习政治。	</p>
<h3 id="第三十周（7-8——7-13）"><a href="#第三十周（7-8——7-13）" class="headerlink" title="第三十周（7.8——7.13）"></a>第三十周（7.8——7.13）</h3><p>数学：听完了第三章一元函数积分学的课，听完了概率论的强化课，但是感觉不是很好，坚持每天做概率题</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*一元函数积分学
	不定积分
    	变上限积分函数意味着可积，可积不一定是原函数
    	三角函数不定积分，凑谁最重要，该符号后，任然保持不变的去凑
    	例8，高次函数函数，三次幂考察效率比较高
    	抽象函数，只给出导函数，无法求原函数，大概率使用分部积分
    	分段函数的不定积分
    定积分
    	连续必可积，可积不一定连续
    	可积必有界，有界不一定可积，迪利克雷函数，处处不连续，处处不可导，处处不可积
    	106例1，定积分的定义
    	106例2例3，积分中值定理
    	108例2，周期函数积分，只求一个周期就可以
    	108例6，抽象函数，变上限积分，结果求积分，使用分部积分去掉积分号
    	108例11，注，出现y&#39;,且x-a形式，分布积分前要先把dx写成dx-a
    变上限积分函数及应用
    	变上限积分恒连续，因为可积必连续
    	F(x)&#39;&#x3D;limf(x),永远求导都是极限值，不是函数值，如果f(x)连续，那么极限值等于函数值，正好是原函数
    	116例8，最值肯定与导数有关
    积分不等式
    	柯西积分不等式
    	119注，放缩
    	121例5，例6，柯西积分不等式，变上限积分函数
    	补充题，出现高阶，还有积分不等式，泰勒
    反常积分
    	两类积分，两种尺子，张宇助记
    	使用两种尺子比较时，先进行部分积分，化成xp的形式
    定积分的应用
    	咕噜金定理，2pi*形心距离*曲线长度是旋转面积，2pi*形心距离*曲线面积是旋转体积
*&#x2F;</code></pre>

<p>英语：完成了2012年的后两篇和2005年的第一篇</p>
<p>专业课：复习时间已经调整，效率很快就提上来</p>
<p>政治：再过几天就开始，打算徐涛强化课，1000题，后期跟空卡和腿姐的带背</p>
<h3 id="第三十一周（7-14———–7-21）"><a href="#第三十一周（7-14———–7-21）" class="headerlink" title="第三十一周（7.14———–7.21）"></a>第三十一周（7.14———–7.21）</h3><p>数学:完成了第三章的1800二刷，880二刷，660二刷；严选题，880综合，660综合</p>
<pre><code>    继续刷概率论和线代，另外，每天坚持看拿铁的每日一题，帮助很大
</code></pre>
<p>英语：刷了2013年的前三篇</p>
<p>专业课：复习完了链表和顺序表，代码题难度适中，完成了栈的客观题，</p>
<p>政治：开始徐涛强化班和1000题的刷题，1000题看斯基的讲解，小谭的规划和刷题清单，空卡的带背</p>
<p>每一科都加一个思维导图。</p>
<h3 id="第三十二周（7-22—–7-25）"><a href="#第三十二周（7-22—–7-25）" class="headerlink" title="第三十二周（7.22—–7.25）"></a>第三十二周（7.22—–7.25）</h3><p>数学：线代线性方程组强化完成，继续线代和概率的刷题</p>
<p>英语：完成了2013年最后一篇和2012年前两篇</p>
<p>专业课：复习完栈和队列，准备先看串再看数组和广义表</p>
<p>政治：这周有点偷懒，没有坚持政治的学习</p>
<h3 id="第三十三周（7-26———7-30）"><a href="#第三十三周（7-26———7-30）" class="headerlink" title="第三十三周（7.26———7.30）"></a>第三十三周（7.26———7.30）</h3><p>数学：完成了微分方程及应用，继续概率和线代的刷题，武神的17堂课实际上就是之前看过几个up主的解题技巧，有碎片时间就看这些up主的技巧，真的很有帮助</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*微分方程及应用
	通解含有未知常数，特解不含有未知数
	偏积分一定要熟，对后面解题很有帮助
	高阶微分方程
		常系数方程的特解的设法是设一样的形式，代入方程去求特解
		C1,C2,是用题目给的条件，因为题目给出的是方程所有的解都要满足，所以必须代入到所有解里面
		欧拉方程，记住x&#x3D;et,就可以了，然后，D直接写成r来计算
	解微分方程时，解不出来时，首先考虑，将自变量和因变量互换，行不通，考虑其他的换元，y&#x2F;x,yx,y+x
    自变量与因变量互换
    	1.直接，把dx,dy互换，就可以，一般一阶方程这么做
    	2，需要重新写出dx&#x2F;dy,一般高阶方程这么做
    p143,3,4,5,6
    分离变量时，要用到乘除，把变量凑到一块，所以当因变量做分母时，要先验证题目给出的条件是不是就是等于0的条件，	  如果是，就不能分离变量
    根据特解，反推微分方程，
    	常系数微分方程：特解公共部分是特解，剩下是通解
    	非常系数微分方程：相减，得到同解，然后写出特解，代入方程，消去C1,C2得到方程
    p145,5,7
*&#x2F;</code></pre>

<p>英语：完成了2014和2015前两篇</p>
<p>专业课：看完数组和广义表和串，树开了个头，要把学过的内容再浏览复盘一遍</p>
<p>政治：政治速度要赶快，上一周没有学政治，进度慢了，争取返校前能学完马原和毛中特。</p>
<h3 id="第三十四周（7-31—-8-3）"><a href="#第三十四周（7-31—-8-3）" class="headerlink" title="第三十四周（7.31—-8.3）"></a>第三十四周（7.31—-8.3）</h3><p>数学：特征值与特证向量结束，争取最后高数只剩下多重积分应用和级数</p>
<p>英语：完成了2015年和2016年第一篇</p>
<p>政治:争取复习完马原毛概</p>
<p>专业课：树争取抓紧结束，先把肯定要考的先看完，再去看其他的</p>
<h3 id="天气开始变热了，今年雨季比往年时间都长，去自习室要带伞了，加油！！！"><a href="#天气开始变热了，今年雨季比往年时间都长，去自习室要带伞了，加油！！！" class="headerlink" title="天气开始变热了，今年雨季比往年时间都长，去自习室要带伞了，加油！！！"></a>天气开始变热了，今年雨季比往年时间都长，去自习室要带伞了，加油！！！</h3><h3 id="第三十五周（8-4——-8-10）"><a href="#第三十五周（8-4——-8-10）" class="headerlink" title="第三十五周（8.4——-8.10）"></a>第三十五周（8.4——-8.10）</h3><p>这周到开学一直下雨，还是坚持来自习室，这周摆了两天，上学前一定要把专业课过一遍，政治学完毛概和马原，高数最多剩两章，线代完成，概率660做完，英语听完小作文和大作文课，这周嗓子发炎了，效率有点低。</p>
<p>英语：完成了2016年的文章，学习了石雷鹏的一节作文课</p>
<p>政治：尽快学完马原</p>
<p>专业课：树马上就结束了，尽快，树的代码是最多的，后面图，查找，排序就相对减轻一点了</p>
<p>数学：回学校后争取在9.10后可以做真题和模拟卷，这周完成了多元函数微分，概率论做题还是比较吃力，跟着660的老师做，重点是理解思路</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*多元函数微分学
	多元极限，凯哥的思想，如果不能化成平方，就用无穷小之和
	函数可微的判定，偏导数连续，必须是(x,y)-&gt;(0,0),
	p157例3
	p159例7，二元函数的增量写成两个偏增量
	全微分的条件p&#x2F;x&#x3D;&#x3D;q&#x2F;y
	p166例5，画树图，看叶子结点
	求微分，直接用全微分的关系来算
	极值的判定，保号性，阶数高低
	p182例7，任意数，设k的式子
	拉格朗日计算
		x,y&#x2F;对称，FX于FY相减
		反解x,y,z
		凑条件式子
		三元线性方程组
*&#x2F;</code></pre>

<h3 id="第三十六周（8-11–8-16）"><a href="#第三十六周（8-11–8-16）" class="headerlink" title="第三十六周（8.11–8.16）"></a>第三十六周（8.11–8.16）</h3><p>线代完成强化，高数完成了线性代数几何和向量空间</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*向量空间与解析几何
旋转曲面方程的推导，一个是一个坐标不会变，一个是到旋转轴的距离不会变
点到直线的距离，要记住方向向量和特殊点的公式
平行六面体的体积是混合积的模
求两条异面直线的距离可以写出过一条直线的平面，使平面与另一条直线平行，求另一条直线上的点到平面的距离
求与两条直线垂直且相交的直线方程，可以先求出与两条直线都垂直的直线的方向向量，根据求出的方向向量和直线的方向向量求出两平面的法向量，然后所求直线就是两平面的交线
方向导数的定义和和几何意义
*&#x2F;</code></pre>



<p>政治复习完马原，开始复习史纲，先复习完史纲，再复习毛中特，零散时间比较多，可以跟着卡妈的带背，和蝶澈的1000题带背</p>
<p>英语：争取开学前复习完小作文和完型，小作文多写，自然就能形成模板，同时，注意要多背，最后20天在家复习，所以尽量在零散时间背单词和作文，同时二刷阅读真题</p>
<p>专业课尽量在开学前复习完</p>
<h3 id="第三十七周—-第三十九周（8-17—–9-4）"><a href="#第三十七周—-第三十九周（8-17—–9-4）" class="headerlink" title="第三十七周—-第三十九周（8.17—–9.4）"></a>第三十七周—-第三十九周（8.17—–9.4）</h3><p>这几周效率很低，争取开学前能把英语小作文和政治看完，高数最后两章留到学校去看</p>
<p>政治：复习完史纲，争取开学前看完毛中特和思修</p>
<p>英语：开学前看完小作文，阅读留到学校去刷</p>
<p>专业课：暂时先不看，留到学校去看</p>
<p>数学:概率论的660刷完，概率论的做题逃离也比较了解，回学校后还是要把概率论的内容看看</p>
<p>880将二重积分和多重积分的应用合到一章，学完第九章再看</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*二重积分
	抽象二重积分一般考虑轮换对称性
	轮换对称性的构造，如果积分区域本身对称，直接更换yx,二重积分值相等
					积分区域本身不对称，再写一个二重积分，将区域的yx与函数yx互换，两二重积分值相等
	二重积分极坐标交换积分次序，画圆法
	二重积分不好积，首先考虑交换积分次序
	形心坐标与二重积分的互推
	p191例14，二重积分，xy互换，构造轮换对称性
	p193例5，二重积分换元
	二重积分中值定理的使用，积分区域的阶数比分母高或相等
	p196例5，全微分
	p196例6，二重积分下的分部积分
	p197例3柯西积分不等式或者构造轮换对称性
	p198例4，能写成两个积分相乘肯定能写成二重积分，所以，可以转化成二重积分来解
*&#x2F;</code></pre>

<h3 id="9-5—9-8返校，打扫宿舍，洗衣服"><a href="#9-5—9-8返校，打扫宿舍，洗衣服" class="headerlink" title="9.5—9.8返校，打扫宿舍，洗衣服"></a>9.5—9.8返校，打扫宿舍，洗衣服</h3><h3 id="第四十周—第四十一周（9-10———–9-17）"><a href="#第四十周—第四十一周（9-10———–9-17）" class="headerlink" title="第四十周—第四十一周（9.10———–9.17）"></a>第四十周—第四十一周（9.10———–9.17）</h3><p>英语：二刷英语真题，还是有部分真题无法理解，尤其是主旨，主旨题尽量多用几个方法做，刷完了05-11年完型，完型的提分并不高，性价比比较低，下周开始新题型</p>
<p>政治：刷完了徐涛的网课，刷完了1000题，政治大纲大改，坚持每天听苏一的课，刷小程序巩固</p>
<p>专业课：复习完树，图还有两个知识点就复习完成，把图这一张的代码过去，后面，查找和排序就快了</p>
<p>数学：</p>
<pre><code>线代：坚持刷线代杨的课，看完了郝崇宇的课，对于概率论的一些理论更加清晰了，下周完成级数，就开始刷真题了，刷真题时期，要坚持做李范全书，补充一些常用的二级结论和做题技巧

高数：复习完三重积分以及多重积分及其应用，完成了响应的660和880和严选题，二刷了880和严选题
</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*三重积分及其应用
	球坐标系的微元要会画图，dr·rda·rsinadb
	二类积分，三个公式的相互转换，
	如果是物理类积分，不论微元是什么都可以代入、
	斯托克斯公式cos类的公式也要记熟，而且，cos一定要模计算
	p253例2，三重积分也可以利用对称性构造
	p254例4，更换三重积分次序，要么从左到右，要么从右到左
	p255例2，线面积分也可以构造对称性
	p258例4，格林公式和高斯公式，挖洞问题
	p262例10，斯托克斯公式，空间曲线问题，如果曲线是一个平面相交，可将平面方程代入，然后使用格林公式
	dx,dy,dz之类的物理类积分都可以使用参数方程问题代入解决
	p263例3，二类积分进行投影，往哪个面上投，就要构造对应坐标轴的函数
	p265例1，第二类面积分偶0奇倍，曲面关于某坐标面对称，对应坐标轴函数偶0奇倍
	轮换对称性：积分曲线方程，xyz互换，方程不变
			  积分区域轮换对称，尽量使用坐标代换使其满足球体，就能使用轮换对称
*&#x2F;</code></pre>

<h3 id="第四十二周（9-17———–9-22）"><a href="#第四十二周（9-17———–9-22）" class="headerlink" title="第四十二周（9.17———–9.22）"></a>第四十二周（9.17———–9.22）</h3><p>政治：坚持听苏一的马原框架，找时间跟腿姐先背马原，过几天开始技巧课，用小程序刷1000题，然后每周一回顾，把二刷还错的题导出pdf</p>
<p>英语：看完新题型的理论课，新题型的技巧性要比阅读强很多，还是熟练用斌斌的方法，找一档词和二档词，排除部分选项</p>
<p>专业课：复习完图，图的代码不是很多，就几个比较经典的算法，查找，重点是，查找判定树平均查找长度的计算，二叉排序树的算法要多下点功夫</p>
<p>数学：看了郝崇宇的概率论课，感觉一些概念已经清晰了不少，线代杨的课，一般找一些零碎时间看，这周复习完高数的级数，再过两天看凯哥的级数课，9.22数学复习强化正式结束</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*级数，中间会加一些凯哥讲的东西
	级数收敛和发散的几种判别方法
	级数通项加绝对值会变大，所以加了绝对值后收敛，原级数一定收敛
	级数通项加括号会变小，所以加了括号发散，原级数一定发散
	正项级数收敛还是发散时，如果需要等价无穷小替换，一般会和放缩相结合
	绝对收敛+条件收敛一定是条件收敛
	绝对收敛+绝对收敛一定是绝对收敛
	放缩时如果用极限，就会考虑到极限有界，然后变成1&#x2F;np的形式
	收敛区间，收敛半径，收敛域的概念
	条件收敛，就是收敛区间的端点
	和函数与微分方程结合起来考
凯哥
	斯特林公式，n!的大小，lnn的大小
	三角函数区间拉回
	欧拉常数
	对数判别法的使用和证明
小崔
	傅里叶级数，三角函数系，傅里叶级数推导
*&#x2F;</code></pre>

<h3 id="第四十三周-9-22——–9-28"><a href="#第四十三周-9-22——–9-28" class="headerlink" title="第四十三周(9.22——–9.28)"></a>第四十三周(9.22——–9.28)</h3><p>数学：这周完成了数学相关的题目，李正元复习全书感觉并不是很有帮助，先复习辅导讲义，把一些经典的题型做个总结，然后国庆后开始上手真题，前几年先不要计时，先正常做，后期10年之后的题开始计时，同时10年之后的题一定要二刷，然后开始上手李林卷和合工大的题</p>
<p>英语：新题型理论课复习完成，还是先坚持刷英语阅读，英语阅读刷完之后，开始刷新题型并且开始看唐静的翻译</p>
<p>专业课：数据结构强化一轮完成，开始大量刷题，首先是选填汇总，再一个是10+8后面的每一章，这一轮过完之后开始，看真题</p>
<p>政治：腿姐技巧课开始看，继续用小程序去刷1000题，腿姐的技巧确实很好用，有种在听阅读理论课的感觉，但是很好用，记笔记的话，把笔记记到对应的页码上，然后根据笔记的大纲，一边背，一边复习课上的技巧课，苏一的思维导图就做补充了，先不坚持看了，听技巧课不懂的话再去看和补充</p>
<h3 id="第四十四周-9-29———10-4"><a href="#第四十四周-9-29———10-4" class="headerlink" title="第四十四周(9.29———10.4)"></a>第四十四周(9.29———10.4)</h3><p>数学：复习了高数，线代，概率一些结论，定义，一些题型的经典做法和技巧，刷了2套真题，发现，有些定义还是不是很会灵活运用，概率的有些公式比较容易忘，还是要多做题多巩固</p>
<p>英语：坚持刷英语阅读，刷完后看翻译</p>
<p>政治：腿姐马原部分的选择题技巧已经看完，开始看分析题的技巧和模板，背诵手册坚持开始背就行，每学完一个部分，用小程序去刷题就行</p>
<p>专业课：这周又把数据结构过了一轮，一些经典的性质结论，还是要反复的去巩固，要把理论定义搞清楚，打算刷完后，做十套卷，最后刷1800</p>
<h3 id="第四十五周（10-5————–10-10）"><a href="#第四十五周（10-5————–10-10）" class="headerlink" title="第四十五周（10.5————–10.10）"></a>第四十五周（10.5————–10.10）</h3><p>数学：真题刷了4套，开始找时间看一下王谱的课，学一下普适攻略</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*计算有界区间
*马勒格必
*马克思解决无穷-无穷
*破壳而出（解决ln）
*提马法解决（根号）
*&#x2F;</code></pre>



<p>英语:翻译看完，阅读二刷完成，下周开始刷阅读和新题型，然后再准备大作文和刷完型</p>
<p>政治：这周腿姐没有开课，马原分析题掌握点默析的模板</p>
<p>专业课：坚持复习代码，争取月底之前刷完1800</p>
<h3 id="第四十六周（10-11———–10-15）"><a href="#第四十六周（10-11———–10-15）" class="headerlink" title="第四十六周（10.11———–10.15）"></a>第四十六周（10.11———–10.15）</h3><p>数学真题刷了三套，看完王谱的课和高数小何总结的技巧课，后期还是要不断补充，真题有一部分概率还是要计算，能理解题，一些经典的公式要熟</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*普适攻略
	数列极限，差一级，用笔划
	渐近线，提马归幂，分子提最大，分母提最大，保留一个x,然后，剩余部分泰勒
	***微分算子法，解决的至少是二阶导以上的微分方程
		ekx型，见D就换k,如果分母是0，前面写x,分母对D求导
		sinax型，见D2换为-a2,不能用等比级数的思想，因为，siax，可以无限求导
				分母为0，前面写x,分母对D求导，求导之后会没有D2，分母有理化就会出现D2
		幂函数型，凑等比级数，近水楼台，一般对最低次项，进行提公因数		
		混合型
        	有ekx,把ekx提到前面，然后所有的D改写成D+k的形式，再去解另外两种函数型
        	没有ekx,欧拉之眼，把sinax或者cosax替换成eiax型，然后用第一中混合型去做，cos取实部，sin取虚部
        		eix&#x3D;cos+isinx
  	级数收敛性判断，一阳指，其实就是之前渐近线的提max归幂
  				六脉神剑，其实就是凯哥之前总结的六个公式
*&#x2F;
&#x2F;*小何技巧总结
	暴力拆解有理式,使用条件比较局限，可以做选填
	**积分对称性原则对称区间上的积分&#x3D;f(x)+f(-x)在正区间上的积分
	1&#x2F;（1+f(x)）+1&#x2F;(1+1&#x2F;f(x))&#x3D;1
	arctanf(x)+arctan1&#x2F;f(x)&#x3D;pi&#x2F;2
	arcsinf(x)+arccosf(x)&#x3D;pi&#x2F;2
	***多项式试根法，据说来源张宇
	常数项的因子中肯定有一个是多项式的解，然后，代入就可使用多项式除法
	***极坐标下计算旋转体的体积
	2pi&#x2F;3积分r3*sin(a-b)da,b是旋转轴的角度
	
*&#x2F;
&#x2F;*小元老师
	斯托克斯巧解
	条件也是比较局限，其实就是高斯公式的补面法，如果曲线围成的面是相对比较规则，在三个投影面上比较规则，而且可	 以用三个坐标面围成封闭图形，就可以直接算三个坐标面
*&#x2F;</code></pre>

<p>英语：新题型中小标题的部分已经复习完，开始了七选五和排序，翻译并不打算现在练，先看大作文，总结大作文的套路</p>
<p>其实和小作文差不多，记住一些关键的连词和句式，而且这些句子之前的顺序并不受限，多练几篇就熟了</p>
<p>政治：史纲五大线索，记住每个线索中知识点对应的keyword,要记熟，史纲整个逻辑线的串联，背了马原的25大分析题模板的前12项，争取早点背完，但是要不断复习，月底跟着腿姐开始背</p>
<p>专业课：坚持背代码，刷1800，这周把1800的树的部分除了算法题之外，都刷完了，树的性质考察的比较多，树的算法题暂时先不看，留到后期，先看图，查找，排序的选填，判断和应用，后期这几章的算法题是硬骨头，慢慢啃</p>
<h3 id="第四十七周（10-16———–10-21）"><a href="#第四十七周（10-16———–10-21）" class="headerlink" title="第四十七周（10.16———–10.21）"></a>第四十七周（10.16———–10.21）</h3><p>数学：这周因为要搞一些选修课的项目，而且有课是在上午上的，所以这周只做了一套题，效率比较低，后期还是要尽量提升效率，一定要在月底之前，将18年的真题刷完，然后做张八，李林6，合共5</p>
<p>英语：新题型复习完成，开始看完型，完型还是错的比较多，但是还是要多做，完型感觉是一个比较看重逻辑和学会排除的一块，大作文，石雷鹏的课感觉掌握的差不多了，几个功能句就是那几个，下周打算看潘赟的课，学会九宫格作文法</p>
<p>政治：史纲大题复习完成，重点模板，就是点和析，默写对应的知识点，比较难的一块在于，分题型，找到答题点，有一些题干中会给提示，年份，人物，事件，思修的话，感觉帽子题很多，而且很容易出多选陷阱，所以思修一定记牢记熟</p>
<p>专业课的话：打算这周把排序的题搞完，然后就看剩余几章的算法题</p>
<h3 id="第四十八周-10-22———-10-28"><a href="#第四十八周-10-22———-10-28" class="headerlink" title="第四十八周(10.22———-10.28)"></a>第四十八周(10.22———-10.28)</h3><p>数学：以后上午就没有课了，会有更多的时间刷卷子，这周的话做的卷子还是比较多，打算下周开始刷张八，中间穿插着刷真题，张八刷完后，刷李六，李四，谱三，合工大共创,以后就是上午做卷子，整理，下午的话，专业课英语政治的时间压力就不会很大，所以在下午这段时间可以听一下凯哥他们的课，同时复习880，听咋子哥的讲解，主要是学习一下比较经典的思路和思想</p>
<p>英语：潘赟的课更新的比较慢，所以中间穿插着看一下石雷鹏的课，接着刷17年的卷子，争取11月1号开始跟斌斌18-22的模考，另外又买了真题卷，斌斌的课肯定没有更的那么快，中间继续穿插做之前的阅读和新题型和完型</p>
<p>政治：这周看完了思修的大题和部分毛中特，月底技巧班就会结束开启带背、</p>
<p>专业课：1800刷完，继续背代码，复习之前的题，做一下408的历年真题，很有可能从那上面出题</p>
<h3 id="第四十九周（10-39——-11-2）"><a href="#第四十九周（10-39——-11-2）" class="headerlink" title="第四十九周（10.39——-11.2）"></a>第四十九周（10.39——-11.2）</h3><p>数学：这周因为要做软件测试的课设和报告，只做了18年的真题，效率比较低，进入11月了，每天要坚持刷题，张八，李林6+4，谱三，合工大共创，张四的话，如果时间太紧就暂时不做了，跟着凯哥继续复习一些比较复杂的知识点，记录一些二级结论，880，复习完了第一章，效率还是低，后期一定要把效率提上来</p>
<p>英语：看的22的潘赟的课，潘赟的课更的太慢了，已经学了三个模版，后面先把这三个模版背熟，然后等潘赟的课更完再去看一下新大纲的作文模版，继续刷真题，同时，坚持二刷新题型，阅读的话先把新题型刷完，如果有时间就再刷</p>
<p>政治:腿姐技巧班完结，先跟着腿姐带背，去背，晚上还是要背那些答题的答题模版。</p>
<p>专业课：408历年真题的数据结构部分刷完，又把数据结构的知识简单串了一遍。</p>
<h3 id="第五十周-（11-3————11-8）"><a href="#第五十周-（11-3————11-8）" class="headerlink" title="第五十周 （11.3————11.8）"></a>第五十周 （11.3————11.8）</h3><p>数学：这周的效率还可以，完成了19,20年的真题，写了两套张八，分数都不是比较理想，还是有些基础的知识有些忘了，所以用起来不太熟练，有时候因为不熟就不太敢用，还是要注重一些基本的题型和题源，提高计算能力，张八有一部分是因为计算能力不过关导致的，20年的数学真题真的是很有含金量，14,16，18,20这几年真题后期至少刷三遍，这周同时也看了凯哥的课，收获的还是挺多的，以后武神的每日一题就刷完了，坚持刷凯哥的每日一题</p>
<p>英语：完成了19年的真题和18年的真题，总体来看，这几年完型的难度已经大幅度降低，所以做题顺序可以调整为，作文，阅读，新题型，完型，翻译</p>
<p>政治：这周，主要还是使用anki来刷1000题和记一些帽子题，以后帽子题，先记思修和毛中特，马原的帽子题几乎已经记完，刷马原和史纲的1000，跟腿姐的带背，每天坚持复习，后期政治的时间要慢慢增加了</p>
<p>专业课：还是继续看代码。</p>
<h3 id="第五十一周（11-9———11-15）"><a href="#第五十一周（11-9———11-15）" class="headerlink" title="第五十一周（11.9———11.15）"></a>第五十一周（11.9———11.15）</h3><p>数学：这周效率还是比较低的，只做了21年真题和一套张八，张八的题还是有很大难度的，比较综合，刷题过程中可以在刷题时，如果感觉出有哪块的知识已经忘了，改完卷子要立即去看，这周而且看了凯哥的线代解题班，争取一周内看完</p>
<p>英语：刷了20年真题，这套相对前面几套难度也降低了，新题型的二刷也刷完了，对于新题型的做题步骤也进一步细化，可以开启阅读的三刷了</p>
<p>专业课：还是有一些小问题没有注意到，写过一遍后感觉对代码的思路更清晰了，另外把B树和B+树有重新复习了一遍，以防专业课出现超纲的题。</p>
<p>政治：刷完了米6，徐6，后面找时间刷一下腿4，然后，肖八刷了两套，分数的话还可以，但是还是有一些帽子题和时政不是太清楚，anki的帽子题快背完了，背诵手册下篇的简单句和小知识点也背完了，逐渐把重心挪到背诵题模版上，听了空卡的讲解，有些记忆口诀还是比较有帮助的</p>
<h3 id="第五十二周（11-16———-11-22）"><a href="#第五十二周（11-16———-11-22）" class="headerlink" title="第五十二周（11.16———-11.22）"></a>第五十二周（11.16———-11.22）</h3><p>由于这周有移动应用开发的课设，时间浪费了很多，效率也比较低，后面打算尽量提升速度，争取能在月底结束前刷完李林六和张八，把腿四所有的题都刷完</p>
<p>数学：效率还是比较低的，两套张八，问题还是在线代和概率上，线代主要是一些抽象的概念和推论，概率的话还是要从定义出发，但是一些技巧还是要熟练，高数部分主要是一些计算量大的题的计算技巧要掌握</p>
<p>英语：完成21年真题，这一年失分主要是新题型，新题型把七选五和小标题合在一起了，入手还是从小标题入手，阅读的难度算正常，这一年完型没有错很多</p>
<p>专业课：坚持刷了几天的力扣发现中等题里也有一些比较好的题，所以还是坚持刷，抽空刷，重点还是要把基础和一些重点的代码和性质熟练。</p>
<p>政治：刷完了肖八，使用小程序去刷之前肖八，米6，徐6，很多题的陷阱非常多，一定要记牢记熟。</p>
<h3 id="第五十三周-11-23———11-28"><a href="#第五十三周-11-23———11-28" class="headerlink" title="第五十三周(11.23———11.28)"></a>第五十三周(11.23———11.28)</h3><p>这周还是由于移动应用开发的课设和报告，也浪费了很多时间，完成了张八，还没有开始李六，但是先在李六之前看完武神的选填班，晚上肯定会有部分的空闲时间，所以看强化讲义和880，尽量周全的回顾</p>
<p>数学：两套张八，张八完结，武神的选填班还有两天就能完成，在这周也开始回顾到课本和880，以后尽量是上午写卷子，晚上回顾教材和880</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*武神选填班
	几何法，代入法，排除法是比较常用的
	周期函数性质：一个周期上的积分值&#x2F;T&#x3D;变上限积分&#x2F;x,其中x-&gt;无穷
	数列收敛和数列绝对值收敛之间的关系
	估阶，其中，不同阶取小阶然后nm算法计算，上下限同阶，积分中值，当成幂函数、
	奇函数和偶函数的泰勒是比较爱考察
	幂函数*绝对值函数，n阶导存在，n+1阶导不存在
	对数函数*绝对值函数，n-1阶导存在，n阶导不存在
	积分符号内写泰勒也是比较新的技巧
	构造无穷小  *x,或者脱帽法
	证明异号零点，泰勒放缩
	
*&#x2F;</code></pre>



<p>英语：坚持二刷阅读和新题型</p>
<p>专业课：还是坚持刷力扣，但是还有20多天，还是继续坚持回顾自己的笔记。</p>
<p>政治：这周完成了腿四，还是坚持每天用anki回顾刷题和知识点，现在要坚持背一下大题和知识点，要提前背，到时候背肖四就不会压力太大了</p>
<h3 id="第五十四周（11-29————-12-7）"><a href="#第五十四周（11-29————-12-7）" class="headerlink" title="第五十四周（11.29————-12.7）"></a>第五十四周（11.29————-12.7）</h3><p>这一周是比较艰难的一周，学校里出现了阳性，开始先是在宿舍静默三天，然后莫名其妙的就被赶出来了，和同学在商业街租了房子，好在就住到22号，半个月的时间，也是考研前的最后半个月，这几天重要的是抓紧找回状态，还是坚持做题，但是已经没有办法进行模拟了，所以把模拟卷当成一个一个的小题来刷，至少把李林6+4和王谱的三套卷刷完，把腿姐冲刺班，九页纸，七页纸，肖四刷完背完，还有三周的时间，一定要坚持下来</p>
<p>数学:刷了部分的王谱的卷子，继续看了看880，争取把880的高数和线代看完，完成了两套李林卷，总体来说还行。</p>
<p>英语:这周英语还是坚持二刷真题，这周22年的题模拟做完，然后开始背作文模版，把范文背背</p>
<p>政治：这周政治还是看冲刺班和押题班，尽量刷完肖四开始抓紧背</p>
<p>专业课：把王道的客观题又重新做了一遍。</p>
<h3 id="第五十五周（12-8——-12-14）"><a href="#第五十五周（12-8——-12-14）" class="headerlink" title="第五十五周（12.8——-12.14）"></a>第五十五周（12.8——-12.14）</h3><p>看数学讲义，回顾到教材和笔记里面，英语还是坚持背单词，因为真题这周已经几乎刷完了，所以英语所占用的时间就少了很多，晚上的话，还是看数学笔记教材，刷电子版模拟题，能刷多少刷多少，最后剩1-2小时，背英语作文和政治大题，保底任务，必须把李林6+4和高数线代教材看完，其余按计划完成。</p>
<p>数学：完成了李林6套卷，以后可以在上午和晚上继续刷题，下周把李林4套刷完，王谱剩余的两套刷完，周洋鑫的四套卷，优先做一下线代</p>
<p>英语：完成了22年的阅读，下周完成完型和新题型，同时下周开始背大作文和小作文，把石雷鹏的押题看一下</p>
<p>政治：刷完了肖四，这周开始背肖四，跟着up考研你终硕去背</p>
<p>专业课：坚持每天写，保持手感</p>
<p>数学专业课一定要坚持每天都要复习，保持手感</p>
<h3 id="第五十六周（12-15———–12-21）"><a href="#第五十六周（12-15———–12-21）" class="headerlink" title="第五十六周（12.15———–12.21）"></a>第五十六周（12.15———–12.21）</h3><p>四科的题基本上都刷完了，今天刚做了抗原，上帝保佑，是阴性，没有太多的时间去刷谱三，所以这几天利用时间，把谱三的题先看看，周洋鑫的四套卷看一下线代，刷刷线代杨的题，重点这几天要放在政治背诵，和英语作文背诵了，尽量能在考试之前把背过的东西再多看几遍，好消息就是考试两天可以在校外居住，所以考试做好防护，最后这几天撑下来，可能这是最后一周的每日复盘了，后面一直在听张宇的每日一聊，虽然可能不会有太多帮助，但是可以缓解一下压力，300多天的坚持，加油！！！！</p>
<p>英语：真题基本都完成了二刷，打算最后几天，再把真题拿出来刷刷，保持做题的手感，重点还是背作文，尽量多背功能句比较多的范文，然后考试的时候就很容易变化运用了</p>
<p>政治：刷完了杨亚娟的四套和王吉的四套，打算再把肖四肖八的选择再看几遍，挤时间多看看，主要还是背政治，政治用研途归期的杂糅版，虽然比较多，但是尽量多背，感觉到考场上能输出一大半就基本上差不多了。</p>
<p>数学：李四和22年真题也刷完了，后面就是不断的看真题，看一下李艳芳的真题解析，从多个思路去分析真题，后面把谱三的高数，周四的线代和线代杨的线代看看，然后重点是看一下自己记的笔记和二级结论，尤其是心一，凯哥，小崔，小何，没咋了，柠檬精，面哥这几个up主的笔记</p>
<p>专业课：数学和专业课还是要每天不断做，不断练，代码题也要不断看，保持手感，只有练熟到考场上才不会慌。</p>
<h2 id="考研期间自制思维导图"><a href="#考研期间自制思维导图" class="headerlink" title="考研期间自制思维导图"></a>考研期间自制思维导图</h2><h3 id="高数二级结论"><a href="#高数二级结论" class="headerlink" title="高数二级结论"></a>高数二级结论</h3><p><a href="https://gitmind.cn/app/docs/mmzkbe5d" title="武神&amp;宇哥课外补充">武神&amp;宇哥课外补充</a></p>
<h3 id="概率论结论"><a href="#概率论结论" class="headerlink" title="概率论结论"></a>概率论结论</h3><p><a href="https://gitmind.cn/app/docs/mppauovf" title="郝崇宇解题思路">郝崇宇解题思路</a></p>
<p><a href="https://gitmind.cn/app/docs/my0y1b9c" title="余炳森课思路整理">余炳森课思路整理</a></p>
<h3 id="线代结论"><a href="#线代结论" class="headerlink" title="线代结论"></a>线代结论</h3><p><a href="https://gitmind.cn/app/docs/mady8a93" title="永乐老爷子&amp;宋浩课外补充">永乐老爷子&amp;宋浩课外补充</a></p>
<h3 id="英语阅读"><a href="#英语阅读" class="headerlink" title="英语阅读"></a>英语阅读</h3><p><a href="https://gitmind.cn/app/docs/mzxaaccd" title="斌斌阅读思路整理">斌斌阅读思路整理</a></p>
<p><a href="https://zhimap.com/m/uWAPbkaA" title="阅读刷题">阅读刷题</a></p>
<h3 id="英语小标题"><a href="#英语小标题" class="headerlink" title="英语小标题"></a>英语小标题</h3><p><a href="https://gitmind.cn/app/docs/mqfxx6v1" title="斌斌小标题思路整理">斌斌小标题思路整理</a></p>
<h3 id="英语翻译-amp-amp-完型"><a href="#英语翻译-amp-amp-完型" class="headerlink" title="英语翻译&amp;&amp;完型"></a>英语翻译&amp;&amp;完型</h3><p><a href="https://gitmind.cn/app/docs/mavtz349" title="唐静翻译&amp;斌斌完型">唐静翻译&amp;斌斌完型</a></p>
<h3 id="英语小作文"><a href="#英语小作文" class="headerlink" title="英语小作文"></a>英语小作文</h3><p><a href="https://gitmind.cn/app/docs/mebt3h4r" title="彦祖小作文三段式思路">彦祖小作文三段式思路</a></p>
<h3 id="英语大作文"><a href="#英语大作文" class="headerlink" title="英语大作文"></a>英语大作文</h3><p><a href="https://gitmind.cn/app/docs/mjqa0vqv" title="彦祖大作文三段式思路">彦祖大作文三段式思路</a></p>
<h3 id="英语七选五-amp-amp-排序"><a href="#英语七选五-amp-amp-排序" class="headerlink" title="英语七选五&amp;&amp;排序"></a>英语七选五&amp;&amp;排序</h3><p><a href="https://gitmind.cn/app/docs/mvkp3g5s" title="斌斌七选五&amp;&amp;排序">斌斌七选五&amp;&amp;排序</a></p>
<h3 id="政治技巧班"><a href="#政治技巧班" class="headerlink" title="政治技巧班"></a>政治技巧班</h3><p><a href="https://zhimap.com/m/KLeiUTnP" title="腿姐技巧班思路整理">腿姐技巧班思路整理</a></p>
<h2 id="考研up主推荐"><a href="#考研up主推荐" class="headerlink" title="考研up主推荐"></a>考研up主推荐</h2><p><a href="https://space.bilibili.com/12013281" title="受这位大佬启发开始做的每周复盘，719134806，可以来群里一起交流，考研期间群里有许多大佬会分析报考学校报考分数，并不局限于计算机领域，">北邮大佬</a></p>
<p><a href="https://space.bilibili.com/1078651536?spm_id_from=..search-card.all.click" title="陈文灯大弟子">王谱</a></p>
<p><a href="https://space.bilibili.com/504497972?spm_id_from=..0.0" title="西电宝藏老师">线代杨</a></p>
<p><a href="https://space.bilibili.com/237004182?spm_id_from=..0.0">心一学长</a></p>
<p><a href="https://space.bilibili.com/42428180?spm_id_from=..0.0">凯哥</a></p>
<p><a href="https://space.bilibili.com/25327929?spm_id_from=..0.0">夜雨</a></p>
<p><a href="https://space.bilibili.com/404686329?spm_id_from=..0.0">小崔</a></p>
<p><a href="https://space.bilibili.com/507087121?spm_id_from=..0.0">一枝花</a></p>
<p><a href="https://space.bilibili.com/295210771">阿赞</a></p>
<p><a href="https://space.bilibili.com/28948895">考研数学龙哥</a></p>
<p><a href="https://space.bilibili.com/452790824">没咋了</a></p>
<p><a href="https://space.bilibili.com/19742938">面哥</a></p>
<p><a href="https://space.bilibili.com/457983079?spm_id_from=..0.0">柠檬精</a></p>
<p><a href="https://space.bilibili.com/490527341">小仙女不辣不辣</a></p>
<p><a href="https://space.bilibili.com/20033228/">考研数学小影</a></p>
<p><a href="https://space.bilibili.com/30610471" title="乱杀大佬">湘大汤家凤</a></p>
<p><a href="https://space.bilibili.com/433206672" title="模拟卷分析大佬">晚晴蓝艺</a></p>
<p><a href="https://space.bilibili.com/84140046" title="每日一题，一题多解">拿铁加多糖</a></p>
<p><a href="https://space.bilibili.com/328805110?spm_id_from=..0.0">朱杰</a></p>
<p><a href="https://space.bilibili.com/336036831?spm_id_from=..0.0">考研你终硕</a></p>
<p><a href="https://space.bilibili.com/43614357?spm_id_from=..0.0">研途可期</a></p>
<p><a href="https://space.bilibili.com/360996402?spm_id_from=..0.0">湖科大教书匠</a></p>
<p><a href="https://pan.baidu.com/s/18FpNUcgrl743MxYxOkQTZg#list" title="提取码9357">部分课程</a></p>
<h2 id="部分网站推荐"><a href="#部分网站推荐" class="headerlink" title="部分网站推荐"></a>部分网站推荐</h2><p><a href="https://noobdream.com/">N诺</a></p>
<p><a href="https://www.hifast.cn/">快导航</a></p>
<p><a href="https://www.jokerps.com/">joker</a></p>
<p><a href="https://xydh.fun/echsfxy">二次寒树</a></p>
<p><a href="https://zhaokaifeng.com/">荒原之梦</a></p>
<p><a href="https://authurwhywait.github.io/blog/">Lee</a></p>
<p><a href="https://www.x-mol.com/">xmol</a></p>
<p><a href="http://school.freekaoyan.com/">freekaoyan</a></p>
<p><a href="https://www.open-open.com/">深度开源</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华镜像网</a></p>
<h2 id="考研微信小程序推荐"><a href="#考研微信小程序推荐" class="headerlink" title="考研微信小程序推荐"></a>考研微信小程序推荐</h2><p>考研知音</p>
<p>N诺</p>
<p>永乐讲线代</p>
<p>考研数学欧几里得</p>
<h2 id="考研公众号推荐"><a href="#考研公众号推荐" class="headerlink" title="考研公众号推荐"></a>考研公众号推荐</h2><p>考研英语外刊阅读</p>
<p>计算机考研助手</p>
<p>一烫</p>
<h2 id="考研app推荐"><a href="#考研app推荐" class="headerlink" title="考研app推荐"></a>考研app推荐</h2><p><a href="https://apps.ankiweb.net/" title="有助于记忆政治帽子题">anki助记</a></p>
<p><a href="http://www.estrongs.com/">ES文件浏览器</a></p>
<p><a href="https://www.fenbi.com/page/download">粉笔考研</a></p>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>23考研其实是一段比较难忘的经历，有疫情有甲流，时隔三年突然恢复线下复试，最难忘的就是考试前几天，因为疫情的原因和兄弟们在商业街租了房子，一住就是20天，我和同学刚到房间时，我俩开始找找有什么还能用的，结果居然发现了一口电热锅，我俩当时还纳闷怎么会有个锅在这，不过也正是因为这口锅，解了我俩的燃眉之急，因为疫情原因，很多店家都关门了，吃外卖又担心会被感染不安全，吃饭成了一个大问题。幸运的是还有几家超市开着。同学居然把油盐酱醋都带来了，我们俩去超市屯了鸡蛋，还有些菜，煎鸡蛋，烤肠，烙饼，成了我们的口粮，有时候去楼下超市买些馄炖饺子还有挂面一起煮着吃，就这样坚持到了考试结束。因为疫情，每次出去买菜买吃的，我和舍友都要用酒精和84消毒，出去消杀一遍，回屋消杀一遍，晚上睡觉前再消杀一遍，有次84的浓度调的太高了，喷到屋里直接把眼泪呛出来了。就这样层层防护，我们俩都没有阳，安全的考完了试。考完那天其实心情的话只能是说很平淡，但是确实很高兴，因为这场折磨终于结束了，和同学聊天，开玩笑说，不管后面结果如何，咱们也是过命的交情了，几十年后回想这段经历也是很牛犇的。刺猬在天冷的时候会围抱取暖，但保持一定距离避免相互刺伤。一个人的力量很渺小，但是一群人的力量是无法估量的。</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>阿杜与三弟</title>
    <url>/2023/03/12/%E9%98%BF%E6%9D%9C%E4%B8%8E%E4%B8%89%E5%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/../imag/haden.png" alt="haden"></p>
<h2 id="阿杜与三弟"><a href="#阿杜与三弟" class="headerlink" title="阿杜与三弟"></a>阿杜与三弟</h2><p>从雷霆三少到现在，当雷霆送走哈登时，阿杜也选择了离开，哈登来篮网后因为发挥不好被球迷指责时，阿杜第一时间站出来保护三弟，阿杜情商是低，但是一直在保护自己身边这个可爱的三弟</p>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=817091585&aid=857459922&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=447720611&aid=806944567&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=929724373&aid=221444332&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=1035476295&aid=440452916&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=886456458&aid=859962283&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>



<h2 id="雷霆三少-当年没人相信三个20出头的年轻人带队打进了总决赛"><a href="#雷霆三少-当年没人相信三个20出头的年轻人带队打进了总决赛" class="headerlink" title="雷霆三少 当年没人相信三个20出头的年轻人带队打进了总决赛"></a>雷霆三少 当年没人相信三个20出头的年轻人带队打进了总决赛</h2><div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=432369350&aid=976357276&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>

<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=950579689&aid=222364065&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
</div>
]]></content>
      <categories>
        <category>篮网</category>
      </categories>
      <tags>
        <tag>篮网</tag>
      </tags>
  </entry>
  <entry>
    <title>自制考研数据结构常用代码</title>
    <url>/2023/04/04/%E8%87%AA%E5%88%B6%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="自制数据结构考研常用代码"><a href="#自制数据结构考研常用代码" class="headerlink" title="自制数据结构考研常用代码"></a>自制数据结构考研常用代码</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><h4 id="快慢指针删除重复元素"><a href="#快慢指针删除重复元素" class="headerlink" title="快慢指针删除重复元素"></a>快慢指针删除重复元素</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct sqllist&#123;
	vector&lt;int&gt;res;
&#125;;
typedef struct sqllist sqllist;
void delete_duplicate(sqllist&amp;s)&#123;
	if(s.res.size()&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	&#x2F;&#x2F;无论是否重复，第一个元素肯定保持不动，所以下标从1开始
	int slow&#x3D;1,fast&#x3D;1;
	while(fast&lt;s.res.size())&#123;
		&#x2F;&#x2F;TODO
		if(s.res[fast]!&#x3D;s.res[fast-1])&#123;
			&#x2F;&#x2F;TODO
			&#x2F;&#x2F;fast和slow差一，当fast和slow所指元素相同，fast,一直右移，直到找到不是fast-1，所指元素
			&#x2F;&#x2F;不把fast-1换成slow,是因为考虑下标0
			s.res[slow]&#x3D;s.res[fast];
			slow++;
		&#125;
		fast++;
	&#125;
	s.res.resize(slow);&#x2F;&#x2F;重新设置一下长度
&#125;

int main()&#123;
	&#x2F;&#x2F;双指针实现删除有序数组中的重复元素
	sqllist s;
	s.res&#x3D;&#123;1,2,3,3,4,4,5&#125;;
	delete_duplicate(s);
	for(int num:s.res)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return 0;
&#125;</code></pre>

<h4 id="合并两个顺序表"><a href="#合并两个顺序表" class="headerlink" title="合并两个顺序表"></a>合并两个顺序表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;2.2.3.07合并两个顺序表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct sqllist&#123;
	vector&lt;int&gt;sql;
	int lengh;
	sqllist()&#123;&#125;
	sqllist(int k):lengh(k),sql(k)&#123;&#125;
&#125;;
typedef struct sqllist sqllist;
sqllist mer(vector&lt;int&gt;&amp;s1,vector&lt;int&gt;&amp;s2)&#123;
	sqllist res(s1.size()+s2.size());
	int k&#x3D;0,i&#x3D;0,j&#x3D;0;
	while(i&lt;s1.size()&amp;&amp;j&lt;s2.size())&#123;
		&#x2F;&#x2F;TODO
		if(s1[i]&lt;&#x3D;s2[j])&#123;
			&#x2F;&#x2F;TODO
			res.sql[k]&#x3D;s1[i];
			i++;
			k++;
		&#125;else&#123;
			res.sql[k]&#x3D;s2[j];
			j++;
			k++;
		&#125;
	&#125;
	&#x2F;&#x2F;会有剩下的
	while(i&lt;s1.size())&#123;
		&#x2F;&#x2F;TODO
		res.sql[k]&#x3D;s1[i];
		i++;
		k++;
	&#125;
	while(j&lt;s2.size())&#123;
		&#x2F;&#x2F;TODO
		res.sql[k]&#x3D;s2[j];
		j++;
		k++;
	&#125;
	return res;
&#125;
int main()&#123;
	sqllist s1;
	for(int i&#x3D;0;i&lt;&#x3D;10;i&#x3D;i+2)&#123;
		&#x2F;&#x2F;TODO
		s1.sql.push_back(i);
	&#125;
	sqllist s2;
	for(int i&#x3D;1;i&lt;&#x3D;10;i&#x3D;i+2)&#123;
		&#x2F;&#x2F;TODO
		s2.sql.push_back(i);
	&#125;

	sqllist sres&#x3D; mer(s1.sql,s2.sql);
	for(int num:sres.sql)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return 0;
&#125;</code></pre>

<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; vet;
void change_or_insert(vet&amp;v,int x)&#123;
	int i&#x3D;0,j&#x3D;v.size()-1;
	int mid&#x3D;0;
	while(i&lt;&#x3D;j)&#123;
		&#x2F;&#x2F;TODO
		mid&#x3D;(i+j)&#x2F;2;
		if(v[mid]&#x3D;&#x3D;x)&#123;
			&#x2F;&#x2F;TODO
			break;
		&#125;else if(v[mid]&lt;x)&#123;
			&#x2F;&#x2F;TODO
			i&#x3D;mid+1;
		&#125;else&#123;
			j&#x3D;mid-1;
		&#125;
	&#125;
	if(v[mid]&#x3D;&#x3D;x&amp;&amp;mid!&#x3D;v.size()-1)&#123;
		&#x2F;&#x2F;TODO
		swap(v[mid],v[mid+1]);
	&#125;
	if(i&gt;j)&#123;
		&#x2F;&#x2F;TODO
		i&#x3D;0;

		while(i&lt;v.size())&#123;
			&#x2F;&#x2F;TODO
			if(v[i]&lt;x)&#123;
				&#x2F;&#x2F;TODO，不可能出现&#x3D;x
				i++;
				break;&#x2F;&#x2F;找到x的位置
			&#125;
		&#125;
		v.push_back(v[v.size()-1]);
		for(int j&#x3D;v.size()-2;j&gt;&#x3D;i;j--)&#123;
			&#x2F;&#x2F;TODO
			v[j+1]&#x3D;v[j];
		&#125;
		v[i]&#x3D;x;
	&#125;
&#125;
int main()&#123;
	vet v&#123;1,3,4,5,6,7,8,9,10&#125;;
	change_or_insert(v,2);
	for(int num:v)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;</code></pre>

<h4 id="循环迁移"><a href="#循环迁移" class="headerlink" title="循环迁移"></a>循环迁移</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
vector&lt;int&gt; left_p(int p,vector&lt;int&gt;&amp;a)&#123;
	if(a.size()&#x3D;&#x3D;0)&#123;
		return a;
	&#125;
	vector&lt;int&gt; res;
	for(int i&#x3D;p;i&lt;a.size();i++)&#123;
		&#x2F;&#x2F;TODO
		res.push_back(a[i]);
	&#125;
	for(int i&#x3D;0;i&lt;p;i++)&#123;
		&#x2F;&#x2F;TODO
		res.push_back(a[i]);
	&#125;
	return res;
&#125;
int main()&#123;
	vector&lt;int&gt; a&#123;1,2,3,4,5,10,12,13,14,15&#125;;
	vector&lt;int&gt;res&#x3D;left_p(4,a);
	for(int num:res)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return 0;
&#125;</code></pre>



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;反转链表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode* next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int data):data(data),next(nullptr)&#123;&#125;
	listnode(int data,struct listnode*next):data(data),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* mylist;
void print(listnode *l)&#123;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
		l&#x3D;l-&gt;next;
	&#125;
	cout&lt;&lt;endl;
&#125;
listnode * create_list()&#123;
	listnode* p_head&#x3D;new listnode();
	listnode* p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入链表结点的个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		listnode* p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
listnode * reverse_list(listnode*l)&#123;
	&#x2F;&#x2F;迭代算法
	&#x2F;&#x2F;每一次循环都需要先记录一下p_move的next,否则修改指针后，next就找不到了
	listnode *p_move&#x3D;l;
	listnode *pr&#x3D;nullptr;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		listnode *p_move_next&#x3D;p_move-&gt;next;
		p_move-&gt;next&#x3D;pr;
		pr&#x3D;p_move;
		p_move&#x3D;p_move_next;
		&#x2F;&#x2F;助记，三条语句执行顺序是个闭合环
	&#125;
	return pr;

&#125;
int main()&#123;
	listnode* test_list&#x3D;create_list();
	listnode* res_list&#x3D;reverse_list(test_list-&gt;next);
	print(res_list);
	return 0;
&#125;</code></pre>

<h4 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode* next;
	listnode():data(0),next(nullptr)&#123;&#125;
	listnode(int x):data(x),next(nullptr)&#123;&#125;
	listnode(int x,struct listnode* next):data(x),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
void print(listnode *l)&#123;
	while(l!&#x3D;nullptr)&#123;
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
		l&#x3D;l-&gt;next;
	&#125;
&#125;
&#x2F;&#x2F;合并链表
listnode * merge_list(listnode *l1,listnode *l2)&#123;
	listnode *p_head&#x3D;new listnode(-1);
	listnode *p_move&#x3D;p_head;
	while(l1!&#x3D;nullptr&amp;&amp;l2!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(l1-&gt;data&lt;l2-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p_move-&gt;next&#x3D;l1;
			l1&#x3D;l1-&gt;next;
			p_move&#x3D;p_move-&gt;next;
		&#125;else&#123;
			p_move-&gt;next&#x3D;l2;
			l1&#x3D;l2-&gt;next;
			p_move&#x3D;p_move-&gt;next;
		&#125;
	&#125;
	&#x2F;&#x2F;最后会有l1或者l2有剩下
	if(l1!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		p_move-&gt;next&#x3D;l1;
	&#125;else&#123;
		p_move-&gt;next&#x3D;l2;
	&#125;
	cout&lt;&lt;endl;
	print(p_head);
	cout&lt;&lt;endl;
	return p_head-&gt;next;
&#125;
listnode* create_list()&#123;
	int num&#x3D;-1;
	&#x2F;&#x2F;请输入num,输入0，表示完成
	cout&lt;&lt;&quot;请输入个数&quot;&lt;&lt;endl;
	int count&#x3D;0;

	cin &gt;&gt; count;
	listnode* head&#x3D;new listnode(-1);
	listnode* p_move&#x3D;head;
	int i&#x3D;1;
	while(i&lt;&#x3D;count)&#123;
		cin&gt;&gt;num;
		listnode *p_new&#x3D;new listnode(num);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return head;
&#125;

int main()&#123;
	&#x2F;&#x2F;创建两个链表
	listnode* l1&#x3D;create_list();
	print(l1);
	listnode* l2&#x3D;create_list();
	cout&lt;&lt;endl;
	print(l2);
	cout&lt;&lt;endl;
	listnode* out&#x3D;merge_list(l1-&gt;next,l2-&gt;next);
	print(out);
&#125;</code></pre>

<h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;回文列表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode* next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int data):data(data),next(nullptr)&#123;&#125;
	listnode(int data,struct listnode*next):data(data),next(next)&#123;&#125;
&#125;;
listnode * create_list()&#123;
	listnode *p_head&#x3D;new listnode();
	listnode *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入链表结点的个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个结点&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	return p_head;
&#125;
bool is_huiwei(listnode *l)&#123;
	&#x2F;&#x2F;先将元素全都放入数组，然后双指针遍历
	vector&lt;int&gt;test;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		test.push_back(l-&gt;data);
		l&#x3D;l-&gt;next;
	&#125;
	if(test.size()%2!&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	for(int i&#x3D;0,j&#x3D;test.size()-1;i&lt;(test.size()&#x2F;2);i++)&#123;
		&#x2F;&#x2F;TODO
		if(test[i]&#x3D;&#x3D;test[j])&#123;
			&#x2F;&#x2F;TODO
			j--;
		&#125;else&#123;
			return false;
		&#125;
	&#125;
	return true;
&#125;
int main()&#123;
    listnode *test&#x3D;create_list();
	bool hi&#x3D; is_huiwei(test-&gt;next);
	cout&lt;&lt;hi&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="二进制链表"><a href="#二进制链表" class="headerlink" title="二进制链表"></a>二进制链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode* next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int x):data(x),next(nullptr)&#123;&#125;
	listnode(int x,struct listnode*next):data(x),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
void print(listnode*l)&#123;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
	&#125;
	cout&lt;&lt;endl;
&#125;
listnode * create_list()&#123;
	listnode *p_head&#x3D;new listnode();
	listnode *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入结点的个数&quot;&lt;&lt;endl;
	int counts;
	cin&gt;&gt;counts;
	int i&#x3D;1;
	while(i&lt;&#x3D;counts)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
int bi_cal_list(listnode*l)&#123;
	int res&#x3D;0;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		res&#x3D;res*2+l-&gt;data;
		l&#x3D;l-&gt;next;
	&#125;
	return res;
&#125;
int main()&#123;
	listnode *test&#x3D;create_list();
	int res&#x3D;bi_cal_list(test-&gt;next);
	cout&lt;&lt;res&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="链表重合结点"><a href="#链表重合结点" class="headerlink" title="链表重合结点"></a>链表重合结点</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;判断相交链表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode* next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int data):data(data),next(nullptr)&#123;&#125;
	listnode(int data,struct listnode*next):data(data),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
void print(listnode *l)&#123;
	while(l-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
		l&#x3D;l-&gt;next;
	&#125;
&#125;
listnode * create_list()&#123;
	listnode *p_head&#x3D;new listnode();
	listnode *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入链表元素的个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		int data;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
listnode * create_dup_list(listnode *l,listnode *lnew)&#123;
	listnode *p_move&#x3D;l-&gt;next;
	while(p_move-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		p_move&#x3D;p_move-&gt;next;
	&#125;
	p_move-&gt;next&#x3D;lnew-&gt;next;
	return l;
&#125;
listnode * where_dupnode(listnode *l1,listnode *l2)&#123;
	&#x2F;&#x2F;将l1的点全部加入集合；
	&#x2F;&#x2F;然后加另一个集合，如果有重结点就返回
	unordered_set&lt;listnode*&gt;listnode_co;
	listnode *p_move&#x3D;l1;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		listnode_co.insert(p_move);
		p_move&#x3D;p_move-&gt;next;
	&#125;
	p_move&#x3D;l2;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(listnode_co.count(p_move)!&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			return p_move;
		&#125;
		p_move&#x3D;p_move-&gt;next;
	&#125;
	return nullptr;
&#125;
int main()&#123;
	listnode *l1&#x3D;create_list();
	listnode *l2&#x3D;create_list();
	listnode *lnew&#x3D;create_list();
	listnode *l1dup&#x3D;create_dup_list(l1,lnew);
	listnode *l2dup&#x3D;create_dup_list(l2,lnew);
	listnode * dupnode&#x3D;where_dupnode(l1dup-&gt;next,l2dup-&gt;next);
	if(dupnode&#x3D;&#x3D;nullptr)&#123;
		cout&lt;&lt;&quot;无&quot;&lt;&lt;endl;
	&#125;else&#123;cout&lt;&lt;dupnode-&gt;data&lt;&lt;endl;&#125;
	return 0;
&#125;</code></pre>

<h4 id="判断链表是否环状"><a href="#判断链表是否环状" class="headerlink" title="判断链表是否环状"></a>判断链表是否环状</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode *next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int x):data(x),next(nullptr)&#123;&#125;
	listnode(int x,struct listnode*next):data(x),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
void print(listnode*l)&#123;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
		l&#x3D;l-&gt;next;
	&#125;
&#125;
listnode * creat_list()&#123;
	listnode *p_head&#x3D;new listnode(-1);
	listnode *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入链表结点的个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		&#x2F;&#x2F;TODO
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
&#x2F;&#x2F;构造环链表
listnode * creat_circle(listnode*l)&#123;
	listnode *p_move&#x3D;l-&gt;next;
	&#x2F;&#x2F;请输入尾指针指向第几个位置
	cout&lt;&lt;&quot;请输入尾指针指向第几个位置&quot;&lt;&lt;endl;
	int pos;
	cin&gt;&gt;pos;
	int i&#x3D;1;
	while(i&lt;pos)&#123;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	listnode *p_pos&#x3D;p_move;
	while(p_move-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		p_move&#x3D;p_move-&gt;next;
	&#125;
	&#x2F;&#x2F;cout&lt;&lt;p_move-&gt;data&lt;&lt;endl;
	p_move-&gt;next&#x3D;p_pos;
	return l;
&#125;
bool is_circle(listnode*l)&#123;
	listnode *p_move&#x3D;l;
	unordered_set&lt;listnode*&gt;seen;
	int i&#x3D;1;
	while(p_move-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(seen.count(p_move)&#x3D;&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			seen.insert(p_move);
			p_move&#x3D;p_move-&gt;next;
			i++;
		&#125;else&#123;
			return true;
		&#125;

	&#125;
	return false;
&#125;
int main()&#123;
	listnode *test&#x3D;creat_list();
	print(test);
	cout&lt;&lt;endl;
	listnode *test1&#x3D;creat_circle(test);
	&#x2F;&#x2F;cout&lt;&lt;test1-&gt;data&lt;&lt;endl;
	&#x2F;&#x2F;判断是否有环就是，将链表从头开始访问，同时将访问过的顶点记录来
	&#x2F;&#x2F;有重复的，就直接返回
	bool res&#x3D;is_circle(test1-&gt;next);
	cout&lt;&lt;res&lt;&lt;endl;
	return 0;

&#125;</code></pre>

<h4 id="删除特定值链表"><a href="#删除特定值链表" class="headerlink" title="删除特定值链表"></a>删除特定值链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode *next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int data):data(data),next(nullptr)&#123;&#125;
	listnode(int data,struct listnode*next):data(data),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
void print(listnode*l)&#123;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
		l&#x3D;l-&gt;next;
	&#125;
&#125;
listnode * create_list()&#123;
	listnode *p_head&#x3D;new listnode();
	listnode *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入结点的个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	return p_head;
&#125;
listnode * delete_val(listnode *l,int val)&#123;

	if(l&#x3D;&#x3D;nullptr) return l;&#x2F;&#x2F;空元素

	&#x2F;&#x2F;删除第一个顶点需要考虑到头节点的重新指向
	while(l!&#x3D;nullptr&amp;&amp;l-&gt;data&#x3D;&#x3D;val)&#123;
		&#x2F;&#x2F;TODO
		l&#x3D;l-&gt;next;
	&#125;&#x2F;&#x2F;这里使用while循环避免了val,val,val,val这种情况
	&#x2F;&#x2F;删除的不是第一个结点
	listnode *p_move&#x3D;l;&#x2F;&#x2F;建立一个移动结点
	while(p_move-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(p_move-&gt;next-&gt;data&#x3D;&#x3D;val)&#123;
			&#x2F;&#x2F;TODO
			p_move-&gt;next&#x3D;p_move-&gt;next-&gt;next;

		&#125;else&#123;
			p_move&#x3D;p_move-&gt;next;
		&#125;
	&#125;
	return l;

&#125;

int main()&#123;
	listnode *test&#x3D;create_list();
	test&#x3D;delete_val(test-&gt;next,3);
	print(test);
	return 0;
&#125;
</code></pre>

<h4 id="删除重复链表结点"><a href="#删除重复链表结点" class="headerlink" title="删除重复链表结点"></a>删除重复链表结点</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;删除重复链表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode* next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int x):data(x),next(nullptr)&#123;&#125;
	listnode(int x,struct listnode*next):data(x),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
void print(listnode *l1)&#123;
	while(l1!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l1-&gt;data&lt;&lt;&quot; &quot;;
		l1&#x3D;l1-&gt;next;
	&#125;

&#125;
listnode * creat_list()&#123;
	int num;
	cout&lt;&lt;&quot;请输入链表的个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	listnode *p_head&#x3D;new listnode();
	listnode *p_move&#x3D;p_head;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		int data;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		&#x2F;&#x2F;TODO
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	print(p_head);
	cout&lt;&lt;endl;
	return p_head;
&#125;

listnode * delete_adjacent(listnode *l1)&#123;
	if(l1&#x3D;&#x3D;nullptr) return l1;
	listnode *p_move&#x3D;l1;
	while(p_move-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		if(p_move-&gt;data&#x3D;&#x3D;p_move-&gt;next-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p_move-&gt;next&#x3D;p_move-&gt;next-&gt;next;
			&#x2F;&#x2F;出现这种next-&gt;data的情况，终止条件需要修改成next!&#x3D;null，避免出现空指针还要去访问数值


		&#125;else&#123;
			p_move&#x3D;p_move-&gt;next;
		&#125;

	&#125;

	return l1;
&#125;
int main()&#123;
	listnode *test&#x3D;creat_list();
	listnode *newtest&#x3D;delete_adjacent(test-&gt;next);&#x2F;&#x2F;test-&gt;next直接开始就是输入
	print(newtest);
	return 0;
&#125;</code></pre>

<h4 id="中间链表"><a href="#中间链表" class="headerlink" title="中间链表"></a>中间链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;返回中间链表结点
&#x2F;&#x2F;设计一个vector&lt;listnode&gt;然后就实现了随机存储
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode *next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int data):data(data),next(nullptr)&#123;&#125;
	listnode(int data,struct listnode*next):data(data),next(next)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* list;
typedef vector&lt;listnode*&gt; lisv;
listnode* create_list()&#123;
	listnode *p_head&#x3D;new listnode();
	listnode *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;请输入链表结点的个数&quot;&lt;&lt;endl;
	int size;
	cin&gt;&gt;size;
	int pos&#x3D;1;
	while(pos&lt;&#x3D;size)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;pos&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		pos++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
listnode * midnode(listnode *l)&#123;
	lisv vl;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		vl.push_back(l);
		l&#x3D;l-&gt;next;
	&#125;
	return vl[vl.size()&#x2F;2];
&#125;
int main()&#123;
	listnode *test&#x3D;create_list();
	listnode *res&#x3D;midnode(test-&gt;next);
	cout&lt;&lt;res-&gt;data&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="保留公共结点"><a href="#保留公共结点" class="headerlink" title="保留公共结点"></a>保留公共结点</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建公共元素，并删除多余结点
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node *next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l-&gt;next;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	int num;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	return p_head;
&#125;
void dele_get_common(slist&amp;l1,slist&amp;l2)&#123;
	list_node *p_move1&#x3D;l1-&gt;next;
	list_node *p_move2&#x3D;l2-&gt;next;
	list_node *p_move&#x3D;l1;
	l1-&gt;next&#x3D;nullptr;
	while(p_move1!&#x3D;nullptr&amp;&amp;p_move2!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(p_move1-&gt;data&lt;p_move2-&gt;data)&#123;
			list_node *p&#x3D;p_move1;
			p_move1&#x3D;p_move1-&gt;next;
			free(p);
		&#125;
		else if(p_move1-&gt;data&gt;p_move2-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			list_node *p&#x3D;p_move2;
			p_move2&#x3D;p_move2-&gt;next;
			free(p);
		&#125;
		else&#123;
			p_move-&gt;next&#x3D;p_move1;
			p_move1&#x3D;p_move1-&gt;next;
			list_node *p&#x3D;p_move2;
			p_move2&#x3D;p_move2-&gt;next;
			free(p);
			p_move&#x3D;p_move-&gt;next;&#x2F;&#x2F;始终指向最后一个结点尾插法
			&#x2F;&#x2F;删除一个留一个
		&#125;
	&#125;
	&#x2F;&#x2F;将多余的结点删除
	while(p_move2!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		list_node *p&#x3D;p_move2;
		p_move2&#x3D;p_move2-&gt;next;
		free(p);
	&#125;
	while(p_move1!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		list_node *p&#x3D;p_move1;
		p_move1&#x3D;p_move1-&gt;next;
		free(p);
	&#125;
&#125;
int main()&#123;
	slist l1&#x3D;create();
	display(l1);
	slist l2&#x3D;create();
	display(l2);
	dele_get_common(l1,l2);
	display(l1);
	return 0;
&#125;</code></pre>

<h4 id="链表暴力匹配"><a href="#链表暴力匹配" class="headerlink" title="链表暴力匹配"></a>链表暴力匹配</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;暴力算法模式匹配链表结构
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node *next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	int num;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	return p_head;
&#125;
bool is_son(slist&amp;dad,slist&amp;son)&#123;
	list_node *p_move_dad&#x3D;dad-&gt;next;
	list_node *p_move_son&#x3D;son-&gt;next;
	list_node *p_move_dadpre&#x3D;dad;
	list_node *p_move_sonpre&#x3D;p_move_son;
	while(p_move_dad!&#x3D;nullptr&amp;&amp;p_move_son!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(p_move_son-&gt;data&#x3D;&#x3D;p_move_dad-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p_move_dadpre&#x3D;p_move_dad;
			p_move_dad&#x3D;p_move_dad-&gt;next;
			p_move_son&#x3D;p_move_son-&gt;next;
		&#125;else&#123;
			&#x2F;&#x2F;儿子回溯到第一个
			p_move_son&#x3D;p_move_sonpre;
			&#x2F;&#x2F;父亲回溯到上次结点的下一个
			p_move_dadpre&#x3D;p_move_dadpre-&gt;next;
			p_move_dad&#x3D;p_move_dadpre-&gt;next;
		&#125;
	&#125;
	&#x2F;&#x2F;儿子先结束，说明是，否则不是
	if(p_move_son&#x3D;&#x3D;nullptr) return true;
	else&#123;return false;&#125;
&#125;
int main()&#123;
	slist l1&#x3D;create();
	display(l1);
	slist l2&#x3D;create();
	display(l2);
	cout&lt;&lt;is_son(l1,l2);
	return 0;
&#125;</code></pre>

<h4 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;单链表插入排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node* next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;

	&#125;
	list_node *p_move&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
	return;
&#125;
slist create()&#123;
	int num;
	cout&lt;&lt;&quot;请输入链表结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;

	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
void insert_sort(slist&amp;l)&#123;
	&#x2F;&#x2F;定义三个指针，新链表一个，旧链表一个指向当前要准备插入的，一个指向其后继
	list_node *p&#x3D;l-&gt;next;&#x2F;&#x2F;拿第一个元素做有序序列，p和p之前都是有序序列
	list_node *r&#x3D;p-&gt;next;&#x2F;&#x2F;指向p的后继，便于往后移动，
	list_node *f&#x3D;l;&#x2F;&#x2F;指向头节点，每次从头节点开始遍历，查找位置，确定位置只能next-&gt;data,必须头节点开始
	&#x2F;&#x2F;开始排序从第二个元素开始
	p-&gt;next&#x3D;nullptr;
	p&#x3D;r;
	while(p!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;查找位置
		r&#x3D;p-&gt;next;&#x2F;&#x2F;记录下一个结点，便于后移

		while(f-&gt;next!&#x3D;nullptr&amp;&amp;f-&gt;next-&gt;data&lt;p-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			&#x2F;&#x2F;必须把f-&gt;next!&#x3D;nullptr放在前面，避免访问空指针
			f&#x3D;f-&gt;next;
		&#125;
		p-&gt;next&#x3D;f-&gt;next;
		f-&gt;next&#x3D;p;
		p&#x3D;r;
		f&#x3D;l;&#x2F;&#x2F;f回溯
	&#125;
&#125;
int main()&#123;
	slist l&#x3D;create();
	display(l-&gt;next);
	insert_sort(l);
	cout&lt;&lt;endl;
	display(l-&gt;next);
	return 0;
&#125;

&#x2F;&#x2F;单链表插入排序改版
&#x2F;&#x2F;单链表插入排序不同的是，每次查找都是从前往后找，因为没有前驱指针
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct listnode&#123;
	int data;
	struct listnode *next;
	listnode():data(-1),next(nullptr)&#123;&#125;
	listnode(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct listnode* slist;
void create(slist&amp;l)&#123;
	listnode *p_move&#x3D;l;
	cout&lt;&lt;&quot;输入个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;输入结点&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		listnode *p_new&#x3D;new listnode(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
&#125;
void display(slist l)&#123;
	while(l!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;l-&gt;data&lt;&lt;&quot; &quot;;
		l&#x3D;l-&gt;next;
	&#125;
&#125;
&#x2F;&#x2F;插入排序
void insertsort(slist&amp;l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;

	listnode *p_head&#x3D;l;

	listnode *p_move&#x3D;l-&gt;next;
	listnode *p_movenext&#x3D;p_move-&gt;next;

	p_move-&gt;next&#x3D;nullptr;&#x2F;&#x2F;防止出现环链
	p_move&#x3D;p_movenext;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO从第二个元素开始查找位置
		p_movenext&#x3D;p_move-&gt;next;
		p_head&#x3D;l;
		while(p_head-&gt;next!&#x3D;nullptr&amp;&amp;p_head-&gt;next-&gt;data&lt;p_move-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p_head&#x3D;p_head-&gt;next;
		&#125;
		p_move-&gt;next&#x3D;p_head-&gt;next;
		p_head-&gt;next&#x3D;p_move;


		p_move&#x3D;p_movenext;
	&#125;
&#125;
int main()&#123;
	slist l&#x3D;new listnode();
	create(l);
	display(l-&gt;next);
	insertsort(l);
	cout&lt;&lt;endl;
	display(l-&gt;next);
	return 0;
&#125;</code></pre>

<h4 id="链表查找倒数第k个元素"><a href="#链表查找倒数第k个元素" class="headerlink" title="链表查找倒数第k个元素"></a>链表查找倒数第k个元素</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;单链表找到倒数第k个元素
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node* next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l-&gt;next;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;

&#125;
slist create()&#123;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	int num;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个结点&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	return p_head;
&#125;
int find_k(slist&amp;l,int k)&#123;
	list_node *p&#x3D;l-&gt;next;
	list_node *q&#x3D;l-&gt;next;
	int i&#x3D;1;
	while(p-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(i&lt;k)&#123;
			&#x2F;&#x2F;TODO
			p&#x3D;p-&gt;next;
			i++;
		&#125;else&#123;

			p&#x3D;p-&gt;next;
			q&#x3D;q-&gt;next;
			i++;
		&#125;
	&#125;
	if(i&lt;&#x3D;k)&#123;
		&#x2F;&#x2F;TODO
		return 0;
	&#125;
	return q-&gt;data;
&#125;
int  main()&#123;
	cout&lt;&lt;&quot;输入k&quot;&lt;&lt;endl;
	int k;
	cin&gt;&gt;k;
	slist l&#x3D;create();
	display(l);
	cout&lt;&lt;endl;
	cout&lt;&lt;find_k(l,k)&lt;&lt;endl;
&#125;</code></pre>

<h4 id="链表删除唯一最小值"><a href="#链表删除唯一最小值" class="headerlink" title="链表删除唯一最小值"></a>链表删除唯一最小值</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;单链表删除最小值（唯一）
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node *next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(list_node *l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	cout&lt;&lt;&quot;请输入结点个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
void delete_min(slist&amp;l)&#123;
	list_node *min_node&#x3D;l-&gt;next;
	list_node *min_front&#x3D;l;
	list_node *p_move&#x3D;l-&gt;next;
	list_node *p_move_front&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(p_move-&gt;data&lt;min_node-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			min_node&#x3D;p_move;
			min_front&#x3D;p_move_front;
		&#125;
		p_move_front&#x3D;p_move;
		p_move&#x3D;p_move-&gt;next;

	&#125;
	&#x2F;&#x2F;删除最小值结点
	min_front-&gt;next&#x3D;min_node-&gt;next;
	free(min_node);
&#125;
int main()&#123;
	slist l&#x3D;create();
	display(l);
	delete_min(l);
	display(l-&gt;next);
&#125;</code></pre>

<h4 id="链表递增输出"><a href="#链表递增输出" class="headerlink" title="链表递增输出"></a>链表递增输出</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;递增输出结点，并将空间释放，与单链表删除最小值相同，只不过多了层循环和输出
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node* next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(list_node*l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;

	&#125;
	list_node *p_move&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	cout&lt;&lt;&quot;请输入创建结点个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个值&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	return p_head;
&#125;
void delete_and_out(slist&amp;l)&#123;
	while(l-&gt;next!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;只要还有结点，l-&gt;next就不是空，这是大循环
		list_node *p_move&#x3D;l-&gt;next;
		list_node *p_move_pre&#x3D;l;
		list_node *p_min_move&#x3D;l-&gt;next;
		list_node *p_min_pre&#x3D;l;
		while(p_move!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			if(p_move-&gt;data&lt;p_min_move-&gt;data)&#123;
				&#x2F;&#x2F;TODO
				p_min_move&#x3D;p_move;
				p_min_pre&#x3D;p_move_pre;
				&#x2F;&#x2F;找到最小值后，移动写不写都行，因为下一次比较，肯定执行else
				&#x2F;&#x2F;p_move_pre&#x3D;p_move;
				&#x2F;&#x2F;p_move&#x3D;p_move-&gt;next;
			&#125;else&#123;
				p_move_pre&#x3D;p_move;
				p_move&#x3D;p_move-&gt;next;
			&#125;
		&#125;
		cout&lt;&lt;p_min_move-&gt;data&lt;&lt;&quot; &quot;;
		p_min_pre-&gt;next&#x3D;p_min_move-&gt;next;
		free(p_min_move);
	&#125;

&#125;
int main()&#123;
	slist l&#x3D;create();
	display(l);
	delete_and_out(l);
	return 0;
&#125;</code></pre>

<h4 id="公共元素创建链表"><a href="#公共元素创建链表" class="headerlink" title="公共元素创建链表"></a>公共元素创建链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;公共元素创建链表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node* next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	int num;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
slist get_common(slist&amp;l1,slist&amp;l2)&#123;
	list_node *p_move1&#x3D;l1-&gt;next;
	list_node *p_move2&#x3D;l2-&gt;next;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	while(p_move1!&#x3D;nullptr&amp;&amp;p_move2!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;有顺序，所以每次小的先移动
		if(p_move1-&gt;data&lt;p_move2-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p_move1&#x3D;p_move1-&gt;next;
		&#125;
		else if(p_move1-&gt;data&gt;p_move2-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p_move2&#x3D;p_move2-&gt;next;
		&#125;
		else&#123;
			list_node *p_new&#x3D;new list_node(p_move1-&gt;data);
			p_move-&gt;next&#x3D;p_new;
			p_move&#x3D;p_move-&gt;next;
			&#x2F;&#x2F;同时两指针同时后移
			p_move1&#x3D;p_move1-&gt;next;
			p_move2&#x3D;p_move2-&gt;next;
		&#125;
	&#125;
	return p_head;
&#125;
int main()&#123;
	slist l1&#x3D;create();
	display(l1);
	slist l2&#x3D;create();
	display(l2);
	slist l3&#x3D;get_common(l1,l2);
	display(l3);
	return 0;
&#125;</code></pre>

<h4 id="合并循环链表"><a href="#合并循环链表" class="headerlink" title="合并循环链表"></a>合并循环链表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;合并两个循环单链表
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node *next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void diplay(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l-&gt;next;
	while(p_move!&#x3D;l)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	int num;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;p_head;
	return p_head;
&#125;
void merge_list(slist&amp;l1,slist&amp;l2)&#123;
	list_node *p_move1&#x3D;l1-&gt;next;
	while(p_move1-&gt;next!&#x3D;l1)&#123;
		&#x2F;&#x2F;TODO
		p_move1&#x3D;p_move1-&gt;next;
	&#125;
	p_move1-&gt;next&#x3D;l2-&gt;next;
	list_node *p_move2&#x3D;l2-&gt;next;
	while(p_move2-&gt;next!&#x3D;l2)&#123;
		&#x2F;&#x2F;TODO
		p_move2&#x3D;p_move2-&gt;next;
	&#125;
	free(l2);
	p_move2-&gt;next&#x3D;l1;
&#125;
int main()&#123;
	slist l1&#x3D;create();
	slist l2&#x3D;create();
	merge_list(l1,l2);
	diplay(l1);
	return 0;
&#125;</code></pre>

<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;头插法，递减序列
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node *next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return ;
	&#125;
	list_node *p_move&#x3D;l-&gt;next;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	int num;
	cout&lt;&lt;&quot;请输入个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		int data;
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head;
&#125;
void merge_reverse(slist&amp;l1,slist&amp;l2)&#123;
	list_node *p_move1&#x3D;l1-&gt;next;
	list_node *p_move2&#x3D;l2-&gt;next;
	list_node *p1_next,*p2_next;
	l1-&gt;next&#x3D;nullptr;
	while(p_move1!&#x3D;nullptr&amp;&amp;p_move2!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(p_move1-&gt;data&lt;p_move2-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p1_next&#x3D;p_move1-&gt;next;
			p_move1-&gt;next&#x3D;l1-&gt;next;
			l1-&gt;next&#x3D;p_move1;
			p_move1&#x3D;p1_next;
		&#125;else&#123;
			p2_next&#x3D;p_move2-&gt;next;
			p_move2-&gt;next&#x3D;l1-&gt;next;
			l1-&gt;next&#x3D;p_move2;
			p_move2&#x3D;p2_next;
		&#125;
	&#125;
	&#x2F;&#x2F;最后会有一个剩下
	if(p_move1!&#x3D;nullptr)&#123;
		while(p_move1!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			p1_next&#x3D;p_move1-&gt;next;
			p_move1-&gt;next&#x3D;l1-&gt;next;
			l1-&gt;next&#x3D;p_move1;
			p_move1&#x3D;p1_next;
		&#125;

	&#125;else&#123;
		while(p_move2!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			p2_next&#x3D;p_move2-&gt;next;
			p_move2-&gt;next&#x3D;l1-&gt;next;
			l1-&gt;next&#x3D;p_move2;
			p_move2&#x3D;p2_next;
		&#125;
	&#125;
	free(l2);
&#125;
int main()&#123;
	slist l1&#x3D;create();
	slist l2&#x3D;create();
	display(l1);
	cout&lt;&lt;endl;
	display(l2);
	merge_reverse(l1,l2);
	cout&lt;&lt;endl;
	display(l1);
	return 0;
&#125;</code></pre>

<h4 id="递归删除结点"><a href="#递归删除结点" class="headerlink" title="递归删除结点"></a>递归删除结点</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
#define maxsize 100
using namespace std;
&#x2F;&#x2F;无头结点可以先头节点创立，然后返回头节点next
struct list_node&#123;
	int data;
	struct list_node *next;
	list_node():data(-1),next(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
void display(list_node *l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l;
	while(p_move!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
	cout&lt;&lt;endl;
&#125;
slist create()&#123;
	int num;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;个值&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		list_node *p_new &#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_move&#x3D;p_move-&gt;next;
		i++;
	&#125;
	p_move-&gt;next&#x3D;nullptr;
	return p_head-&gt;next;
&#125;
void recur_delete_X(slist&amp;l,int x)&#123;
	&#x2F;&#x2F;递归跳出条件写在最前面
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	&#x2F;&#x2F;递归操作
	if(l-&gt;data&#x3D;&#x3D;x)&#123;
		&#x2F;&#x2F;TODO
		list_node *p&#x3D;l;
		l&#x3D;l-&gt;next;
		free(p);
		recur_delete_X(l-&gt;next,x);&#x2F;&#x2F;递归下一层
	&#125;else&#123;
		recur_delete_X(l-&gt;next,x);&#x2F;&#x2F;递归下一层
	&#125;

&#125;
int main()&#123;
	list_node *l&#x3D;create();
	display(l);
	recur_delete_X(l,4);
	display(l);
&#125;</code></pre>

<h4 id="循环链表对称"><a href="#循环链表对称" class="headerlink" title="循环链表对称"></a>循环链表对称</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;循环双链表表是否对称
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct list_node&#123;
	int data;
	struct list_node *next;
	struct list_node *prior;
	list_node():data(-1),next(nullptr),prior(nullptr)&#123;&#125;
	list_node(int x):data(x),next(nullptr),prior(nullptr)&#123;&#125;
&#125;;
typedef struct list_node list_node;
typedef struct list_node* slist;
&#x2F;&#x2F;打印循环双链表
void display(slist l)&#123;
	if(l&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	list_node *p_move&#x3D;l-&gt;next;
	while(p_move!&#x3D;l)&#123;
		&#x2F;&#x2F;TODO,当指针循环到头结点，说明遍历完
		cout&lt;&lt;p_move-&gt;data&lt;&lt;&quot; &quot;;
		p_move&#x3D;p_move-&gt;next;
	&#125;
&#125;
slist create()&#123;
	list_node *p_head&#x3D;new list_node();
	list_node *p_move&#x3D;p_head;
	&#x2F;&#x2F;循环双链表头节点初始化
	p_head-&gt;next&#x3D;p_head;
	p_head-&gt;prior&#x3D;p_head;
	int num;
	cout&lt;&lt;&quot;输入结点个数&quot;&lt;&lt;endl;
	cin&gt;&gt;num;
	int i&#x3D;1;
	while(i&lt;&#x3D;num)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;i&lt;&lt;&quot;个数&quot;&lt;&lt;endl;
		int data;
		cin&gt;&gt;data;
		list_node *p_new&#x3D;new list_node(data);
		p_move-&gt;next&#x3D;p_new;
		p_new-&gt;prior&#x3D;p_move;
		p_new-&gt;next&#x3D;p_head;
		p_head-&gt;prior&#x3D;p_new;
		p_move&#x3D;p_new;
		i++;
	&#125;
	return p_head;
&#125;
bool is_symmetry(slist&amp;l)&#123;
	list_node *p&#x3D;l-&gt;next;&#x2F;&#x2F;第一个结点
	cout&lt;&lt;p-&gt;data&lt;&lt;endl;
	list_node *q&#x3D;l-&gt;prior;&#x2F;&#x2F;最后一个结点
	cout&lt;&lt;q-&gt;data&lt;&lt;endl;
	while(p!&#x3D;q&amp;&amp;q-&gt;next!&#x3D;p)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;p!&#x3D;q,奇数截止
		&#x2F;&#x2F;q-&gt;next!&#x3D;p，偶数截止
		if(p-&gt;data&#x3D;&#x3D;q-&gt;data)&#123;
			&#x2F;&#x2F;TODO
			p&#x3D;p-&gt;next;
			q&#x3D;q-&gt;prior;
		&#125;else&#123;
			return false;
		&#125;
	&#125;
	return true;
&#125;
int main()&#123;
	slist l1&#x3D;create();
	display(l1);
	cout&lt;&lt;is_symmetry(l1);
	return 0;
&#125;</code></pre>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="单调栈实现下一个最大元素"><a href="#单调栈实现下一个最大元素" class="headerlink" title="单调栈实现下一个最大元素"></a>单调栈实现下一个最大元素</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;单调栈只能实现下一个更大的元素
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; arr;
arr next_max(arr&amp;num1,arr&amp;num2)&#123;
	stack &lt;int&gt;sta;
	unordered_map&lt;int,int&gt;next_store;
	for(int i&#x3D;0;i&lt;num2.size();i++)&#123;
		&#x2F;&#x2F;TODO
		while(!(sta.empty())&amp;&amp;sta.top()&lt;num2[i])&#123;
			&#x2F;&#x2F;TODO
			next_store[sta.top()]&#x3D;num2[i];
			sta.pop();
		&#125;
		&#x2F;&#x2F;空的时候，入栈，不为空，但是小于栈顶，也入栈
		sta.push(num2[i]);
	&#125;
	&#x2F;&#x2F;剩下的就只是-1了；
	while(!sta.empty())&#123;
		&#x2F;&#x2F;TODO
		next_store[sta.top()]&#x3D;-1;
		sta.pop();
	&#125;
	arr res;
	for(int i&#x3D;0;i&lt;num1.size();i++)&#123;
		&#x2F;&#x2F;TODO
		res.push_back(next_store[num1[i]]);
	&#125;
	for(int num:res)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return res;
&#125;
int main()&#123;
	arr num1&#123;4,1,2&#125;;
	arr num2&#123;1,3,4,2&#125;;
	arr res&#x3D;next_max(num1,num2);
	return 0;
&#125;</code></pre>

<h4 id="二叉树非递归后序遍历"><a href="#二叉树非递归后序遍历" class="headerlink" title="二叉树非递归后序遍历"></a>二叉树非递归后序遍历</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data):data(data),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
typedef vector&lt;int&gt; arr;
void create_tree(tree&amp;root)&#123;
	string ch&#x3D;&quot;&quot;;
	cout&lt;&lt;&quot;请按先序输入，以#表示空&quot;&lt;&lt;endl;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
	&#125;else&#123;
		root&#x3D;new treenode(stoi(ch));
		&#x2F;&#x2F;cout&lt;&lt;root-&gt;data&lt;&lt;endl;
		create_tree(root-&gt;left);
		create_tree(root-&gt;right);
	&#125;

&#125;
void post_order(tree&amp;root,arr&amp;a)&#123;
	stack&lt;treenode*&gt;stree;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	while(!stree.empty()||root!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		while(root!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			a.push_back(root-&gt;data);
			stree.push(root);
			root&#x3D;root-&gt;right;
		&#125;
		&#x2F;&#x2F;当右子树访问到最后
		root&#x3D;stree.top();
		stree.pop();
		root&#x3D;root-&gt;left;
	&#125;



&#125;
int main()&#123;
	treenode *root;
	create_tree(root);
	arr a;

	post_order(root,a);
	reverse(a.begin(),a.end());
	for(int num:a)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return 0;
&#125;</code></pre>

<h4 id="二叉树非递归先序遍历"><a href="#二叉树非递归先序遍历" class="headerlink" title="二叉树非递归先序遍历"></a>二叉树非递归先序遍历</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode* left;
	struct treenode* right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data):data(data),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data,struct treenode*left,struct treenode*right):data(data),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
typedef vector&lt;int&gt; arr;
&#x2F;&#x2F;因为二叉树没有头节点，所以创造时，必须传入参数
void create_tree(tree&amp;root)&#123;
	string ch&#x3D;&quot;&quot;;
	cout&lt;&lt;&quot;请输入元素按先序序列,#表示空&quot;&lt;&lt;endl;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;&#x2F;&#x2F;空，就把结点设成空
	&#125;else&#123;
		root&#x3D;new treenode(stoi(ch));
		create_tree(root-&gt;left);
		create_tree(root-&gt;right);
	&#125;

	return ;


&#125;
void pre_order(tree&amp;root,arr&amp;a)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		return;
	&#125;
	stack&lt;treenode*&gt; stree;
	while(!stree.empty()||root!&#x3D;nullptr)&#123;
		while(root!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			a.push_back(root-&gt;data);
			stree.push(root);
			root&#x3D;root-&gt;left;
		&#125;
		root&#x3D;stree.top();
		stree.pop();
		root&#x3D;root-&gt;right;
		
	&#125;
&#125;
int main()&#123;
	treenode *root&#x3D;new treenode();
	create_tree(root);
	arr a;
	pre_order(root,a);
	for(int num:a)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
</code></pre>

<h4 id="二叉树非递归中序遍历"><a href="#二叉树非递归中序遍历" class="headerlink" title="二叉树非递归中序遍历"></a>二叉树非递归中序遍历</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二叉树的非递归中序遍历
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data):data(data),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data,struct treenode*left,struct treenode*right):data(data),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
typedef vector&lt;int&gt; arr;
void create_tree(tree &amp;node)&#123;
	string ch;
	cout&lt;&lt;&quot;请输入元素，输入#表示空,按先序顺序输入&quot;&lt;&lt;endl;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		node&#x3D;nullptr;
	&#125;else&#123;
		node&#x3D;new treenode(stoi(ch));
		create_tree(node-&gt;left);
		create_tree(node-&gt;right);
	&#125;

&#125;
void inorder(tree&amp;root,arr&amp;a)&#123;
	stack&lt;treenode*&gt;sta;
	while(root!&#x3D;nullptr||!sta.empty())&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;root!&#x3D;null是压栈，sta.empty是弹栈时用的判断条件
		while(root!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			sta.push(root);
			root&#x3D;root-&gt;left;
		&#125;
		&#x2F;&#x2F;此时root指向最左边的子节点（空），开始弹栈
		root&#x3D;sta.top();
		sta.pop();
		a.push_back(root-&gt;data);
		root&#x3D;root-&gt;right;
	&#125;
&#125;
int main()&#123;
	treenode *root&#x3D;new treenode();
	create_tree(root);
	arr a;
	inorder(root,a);
	for(int num:a)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;</code></pre>

<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&#x2F;括号匹配
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
bool is_vaild(string s)&#123;
	stack&lt;char&gt;sta;
	for(char ch : s)&#123;
		if(ch&#x3D;&#x3D;&#39;&#123;&#39;||ch&#x3D;&#x3D;&#39;(&#39;||ch&#x3D;&#x3D;&#39;[&#39;)&#123;
			&#x2F;&#x2F;TODO
			sta.push(ch);
		&#125;else&#123;
			if((ch&#x3D;&#x3D;&#39;&#125;&#39;&amp;&amp;sta.top()&#x3D;&#x3D;&#39;&#123;&#39;)||(ch&#x3D;&#x3D;&#39;]&#39;&amp;&amp;sta.top()&#x3D;&#x3D;&#39;[&#39;)||(ch&#x3D;&#x3D;&#39;)&#39;&amp;&amp;sta.top()&#x3D;&#x3D;&#39;(&#39;))&#123;
				&#x2F;&#x2F;TODO
				sta.pop();
			&#125;else&#123;
				return false;
			&#125;
		&#125;
	&#125;
	return sta.empty();
&#125;
int main()&#123;
	string s;
	cout&lt;&lt;&quot;请输入括号&quot;&lt;&lt;endl;
	cin&gt;&gt;s;
	bool res&#x3D;is_vaild(s);
	cout&lt;&lt;res&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="最小栈的实现"><a href="#最小栈的实现" class="headerlink" title="最小栈的实现"></a>最小栈的实现</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;双栈实现最小栈，每次压栈或出栈时，最小栈也对应相应的入栈和出栈
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
class min_stack &#123;
public:
	stack&lt;int&gt;st;
	stack&lt;int&gt;min_st;
	bool pushs(int x)&#123;
		if(st.empty())&#123;
			st.push(x);
			min_st.push(x);
			return true;
		&#125;else&#123;
			st.push(x);
			int minpop&#x3D;min(min_st.top(),x);
			min_st.push(minpop);
			return true;
		&#125;
		return false;
	&#125;
	bool pops()&#123;
		if(st.empty())&#123;
			&#x2F;&#x2F;TODO
			return false;
		&#125;
		else&#123;
			st.pop();
			min_st.pop();
			return true;
		&#125;
	&#125;
	int top()&#123;
		return st.top();
	&#125;
	int get_min()&#123;
		return min_st.top();
	&#125;
&#125;;
int main()&#123;
	min_stack s;
	s.pushs(1);
	s.pushs(-1);
	s.pushs(3);
	s.pops();
	s.pops();
	cout&lt;&lt;s.get_min()&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="双栈实现队列"><a href="#双栈实现队列" class="headerlink" title="双栈实现队列"></a>双栈实现队列</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;双栈实现队列
&#x2F;*一个栈用来入队，一个栈用来出队，
入队时，将元素压入入栈
出队，如果出栈没有元素，就将入栈的元素全部弹出，然后压入出栈，弹出出栈的栈顶元素
如果出栈有元素，那么直接弹出出栈的栈顶元素
队列满：当入栈不能压栈，同时出栈还有元素，就说明队列已满
队列空，两个栈内都没有元素，说明整个队列都没有元素
*&#x2F;
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxsize 100
struct my_stack&#123;
	int data[maxsize];
	int top;
	my_stack():top(-1)&#123;&#125;
&#125;;
typedef struct my_stack my_stack;
bool is_full(my_stack s)&#123;
	if(s.top&#x3D;&#x3D;maxsize-1)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	return false;
&#125;
bool s_is_empty(my_stack s)&#123;
	if(s.top&lt;0)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	return false;
&#125;
bool push(my_stack&amp;s,int x)&#123;
	if(is_full(s))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	s.top++;
	s.data[s.top]&#x3D;x;
	return true;
&#125;
bool pop(my_stack&amp;s,int&amp;x)&#123;
	if(s_is_empty(s))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	x&#x3D;s.data[s.top];
	s.top--;
	return true;
&#125;
struct dup_stack_que&#123;
	my_stack in;
	my_stack out;
&#125;;
typedef struct dup_stack_que dup_stack_que;
bool que_is_empty(dup_stack_que q)&#123;
	return s_is_empty(q.in)&amp;&amp;s_is_empty(q.out);
&#125;
bool que_is_full(dup_stack_que q)&#123;
	return is_full(q.in)&amp;&amp;(!s_is_empty(q.out));
&#125;
bool push_que(dup_stack_que&amp;q,int x)&#123;
	if(que_is_full(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	push(q.in,x);
	return true;
&#125;
bool pop_que(dup_stack_que&amp;q,int&amp;x)&#123;
	if(que_is_empty(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	if(s_is_empty(q.out))&#123;
		&#x2F;&#x2F;TODO
		int temp;
		while(!s_is_empty(q.in))&#123;
			&#x2F;&#x2F;TODO
			pop(q.in,temp);
			push(q.out,temp);
		&#125;
		pop(q.out,x);
	&#125;else&#123;
		pop(q.out,x);
	&#125;

	return true;
&#125;
int main()&#123;
	dup_stack_que q;
	int i&#x3D;1;
	while(i&lt;&#x3D;5)&#123;
		&#x2F;&#x2F;TODO
		push_que(q,i);
		i++;
	&#125;
	while(!que_is_empty(q))&#123;
		&#x2F;&#x2F;TODO
		pop_que(q,i);
		cout&lt;&lt;i&lt;&lt;&quot; &quot;;
	&#125;

	return 0;
&#125;</code></pre>

<h4 id="栈实现非递归"><a href="#栈实现非递归" class="headerlink" title="栈实现非递归"></a>栈实现非递归</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;栈实现非递归
&#x2F;*首先，这里用的是栈的思想，结构体可能不是类似栈的结构
首先结构体储存在那一层n,每一次层计算的结果
最上一层记录的是第0层，然后逐层往下，赋值每一层是入栈过程
计算每一层是出栈过程
*&#x2F;
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxsize 100
struct mystack&#123;
	int n;
	double pnx;
&#125;;
typedef struct mystack mystack;
double cac(int n,double x)&#123;
	int top&#x3D;-1,i;
	double f1&#x3D;1,f2&#x3D;2*x;
	mystack st[maxsize];
	for(i&#x3D;n;i&gt;&#x3D;2;i--)&#123;
		&#x2F;&#x2F;TODO
		top++;
		st[top].n&#x3D;i;&#x2F;&#x2F;入栈操作，把第几层标上，由下到上
	&#125;
	&#x2F;&#x2F;出栈操作开始计算,由上到下
	while(top&gt;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		st[top].pnx&#x3D;2*x*f2-2*(st[top].n-1)*f1;
		&#x2F;&#x2F;为下一层做准备
		f1&#x3D;f2;
		f2&#x3D;st[top].pnx;
		top--;
	&#125;
	if(n&#x3D;&#x3D;0) return f1;
	return f2;
&#125;
int main()&#123;
	double x&#x3D;5;
	int n&#x3D;3;
	cout&lt;&lt;cac(n,x)&lt;&lt;endl;
&#125;
</code></pre>



<h4 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h4><pre class="language-c++" data-language="c++"><code class="language-c++">bool isnumber(string str)&#123;
        return !(str&#x3D;&#x3D;&quot;+&quot;||str&#x3D;&#x3D;&quot;-&quot;||str&#x3D;&#x3D;&quot;*&quot;||str&#x3D;&#x3D;&quot;&#x2F;&quot;);
    &#125;
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;int&gt; stk;
        int i&#x3D;0;
        while(i&lt;tokens.size())&#123;
            if(isnumber(tokens[i]))&#123;
                stk.push(atoi(tokens[i].c_str()));
            &#125;else&#123;
                int right&#x3D;stk.top();
                stk.pop();
                int left&#x3D;stk.top();
                stk.pop();
                int ans&#x3D;0;
                switch (tokens[i][0])&#123;
                    case &#39;+&#39;:&#123;ans&#x3D;left+right;break;&#125;
                    case &#39;-&#39;:&#123;ans&#x3D;left-right;break;&#125;
                    case &#39;*&#39;:&#123;ans&#x3D;left*right;break;&#125;
                    case &#39;&#x2F;&#39;:&#123;ans&#x3D;left&#x2F;right;break;&#125;
                &#125;
                stk.push(ans);
            &#125;
            
            i++;
        &#125;
        return stk.top();
    &#125;</code></pre>



<h4 id="删除无效括号"><a href="#删除无效括号" class="headerlink" title="删除无效括号"></a>删除无效括号</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;一个栈存储左括号，一个栈记录左括号的位置，
    
string minRemoveToMakeValid(string s) &#123;
        stack&lt;char&gt; cs;
        stack&lt;int&gt; pos;
        int i&#x3D;0;
        while(i&lt;s.size())&#123;
            if(s[i]&#x3D;&#x3D;&#39;(&#39;)&#123;
                cs.push(s[i]);
                pos.push(i);
                i++;
            &#125;else if(s[i]&#x3D;&#x3D;&#39;)&#39;)&#123;
                if(cs.empty())&#123;
                    s.erase(s.begin()+i);&#x2F;&#x2F;不满足的符号删除
                    &#x2F;&#x2F;erase删除后会自动补充,不用i++
                &#125;else&#123;
                    cs.pop();
                    pos.pop();
                    i++;
                &#125;
                
            &#125;else&#123;i++;&#125;
        &#125;
        &#x2F;&#x2F;如果还有多余的左括号
        while(!pos.empty())&#123;
            s.erase(s.begin()+pos.top());
            pos.pop();
        &#125;
        return s;

    &#125;</code></pre>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; arr;
class circle_queue &#123;

public:
	arr a;
	int front;
	int rear;
	int max_size;
	int temp_size;
	&#x2F;&#x2F;初始化
	circle_queue(int k):a(k),max_size(k),temp_size(0),front(0),rear(0)&#123;&#125;
	bool whether_empty()&#123;
		return temp_size&#x3D;&#x3D;0;
	&#125;
	bool whether_full()&#123;
		return temp_size&#x3D;&#x3D;max_size;
	&#125;
	bool push_queue(int data)&#123;
		if(whether_full())&#123;return false;&#125;
		a[rear]&#x3D;data;
		rear&#x3D;(rear+1)%max_size;
		temp_size++;
		return true;
	&#125;
	bool pop_queue()&#123;
		if(whether_empty())&#123;
			return false;
		&#125;
		front&#x3D;(front+1)%max_size;
		temp_size--;
		return true;
	&#125;
	int get_front()&#123;
		if(whether_empty())&#123;
			return -1;
		&#125;
		return a[front];
	&#125;
	int get_rear()&#123;
		if(whether_empty())&#123;
			&#x2F;&#x2F;TODO
			return -1;
		&#125;
		return a[(rear-1+max_size)%max_size];
	&#125;
&#125;;
int main()&#123;
	circle_queue q(5);
	q.push_queue(1);
	q.push_queue(2);
	cout&lt;&lt;q.get_front();
	return 0;
&#125;</code></pre>

<h4 id="双端循环队列"><a href="#双端循环队列" class="headerlink" title="双端循环队列"></a>双端循环队列</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设计循环双端队列,front之后和rear之后是可以确定的，不用加长度取模，其余需要
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; vet;
class circle_db_queue &#123;
private:
		int front;
		int rear;
		vet que;
		int max_size;
		int temp_size;
public:
	circle_db_queue(int k):que(k+1),front(0),rear(0),max_size(k+1),temp_size(0)&#123;&#125;
	bool whether_full()&#123;
		return (rear+1)%max_size&#x3D;&#x3D;front;
	&#125;
	bool whether_empty()&#123;return front&#x3D;&#x3D;rear;&#125;
	bool push_front(int data)&#123;
		if(whether_full())&#123;
			return false;
		&#125;
		front--;
		front&#x3D;(front+max_size)%max_size;
		que[front]&#x3D;data;
		temp_size++;
		return true;
	&#125;
	bool push_rear(int data)&#123;
		if(whether_full())&#123;
			&#x2F;&#x2F;TODO
			return false;
		&#125;
		que[rear]&#x3D;data;
		rear++;
		rear&#x3D;(rear)%max_size;
		temp_size++;
		return true;
	&#125;
	bool pop_front()&#123;
		if(whether_empty())&#123;
			&#x2F;&#x2F;TODO
			return false;
		&#125;
		front&#x3D;(front+1)%max_size;
		return true;

	&#125;
	bool pop_rear()&#123;
		if(whether_empty())&#123;
			&#x2F;&#x2F;TODO
			return false;
		&#125;
		rear--;
		rear&#x3D;(rear+max_size)%max_size;
		return true;
	&#125;
	int get_front()&#123;
		if(whether_empty())&#123;
			&#x2F;&#x2F;TODO
			return -1;
		&#125;
		return que[front];
	&#125;
	int get_rear()&#123;
		if(whether_empty())&#123;
			&#x2F;&#x2F;TODO
			return -1;
		&#125;
		return que[((rear-1)+max_size)%max_size];
	&#125;
&#125;;
int main()&#123;
	circle_db_queue duque(5);
	duque.push_front(1);
	duque.push_front(2);
	duque.push_rear(5);
	duque.push_rear(4);
	cout&lt;&lt;duque.get_front();
	cout&lt;&lt;duque.get_rear();
&#125;</code></pre>

<h4 id="双队列实现栈"><a href="#双队列实现栈" class="headerlink" title="双队列实现栈"></a>双队列实现栈</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;用队列实现栈
&#x2F;&#x2F;两个队列，主队列实现入栈，出栈，弹栈。访问顶端元素，是否为空
&#x2F;&#x2F;队列和栈的出来顺序相反，所以，每次加入一个数就需要一个辅助队列进行重新排序一下
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
class stack1 &#123;
public:
	queue&lt;int&gt;zhu1;
	queue&lt;int&gt;fu2;
	&#x2F;&#x2F;操作主要是根据zhu1队列操作，fu2操作主要是压入新元素来帮助排序
	int pop()&#123;
		int res&#x3D;zhu1.front();
		zhu1.pop();
		return res;
	&#125;
	bool empty()&#123;return zhu1.empty();&#125;
	int top()&#123;return zhu1.front();&#125;
	void push(int x)&#123;
		fu2.push(x);
		&#x2F;&#x2F;开始从主队列的头指针开始，把元素放新加入的x在后面,最后和主队列交换，始终保证主队列是出栈顺序
		while(!zhu1.empty())&#123;
			&#x2F;&#x2F;TODO
			fu2.push(zhu1.front());
			zhu1.pop();
		&#125;
		swap(zhu1,fu2);
	&#125;
&#125;;
int main()&#123;
	stack1 s;
	s.push(1);
	s.push(2);
	s.push(3);
	while(!s.empty())&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;s.pop()&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>



<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;KMP算法
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
vector&lt;int&gt; get_next(string t)&#123;
	int i&#x3D;1,j&#x3D;0;
	vector&lt;int&gt; next(100);
	next[1]&#x3D;0;
	while(i&lt;t.size())&#123;
		&#x2F;&#x2F;TODO
		if(j&#x3D;&#x3D;0||t[i]&#x3D;&#x3D;t[j])&#123;
			&#x2F;&#x2F;TODO
			i++;
			j++;
			next[i]&#x3D;j;
		&#125;else&#123;
			j&#x3D;next[j];
		&#125;
	&#125;
	return next;
&#125;
int kmp(string s,string t,vector&lt;int&gt; next)&#123;
	int i&#x3D;1,j&#x3D;1;
	while(i&lt;s.size()&amp;&amp;j&lt;t.size())&#123;
		&#x2F;&#x2F;TODO
		if(j&#x3D;&#x3D;0||s[i]&#x3D;&#x3D;t[j])&#123;
			&#x2F;&#x2F;TODO
			i++;
			j++;
		&#125;else&#123;
			j&#x3D;next[j];
		&#125;
	&#125;
	if(j&gt;&#x3D;t.size())&#123;
		&#x2F;&#x2F;TODO
		return i-t.size()+1;
	&#125;else&#123;
		return 0;
	&#125;
&#125;
int main()&#123;
	string s&#x3D;&quot;#&quot;;
	string s1;
	cout&lt;&lt;&quot;输入总串&quot;&lt;&lt;endl;
	cin&gt;&gt;s1;
	s&#x3D;s+s1;
	cout&lt;&lt;s&lt;&lt;endl;
	string t&#x3D;&quot;#&quot;;
	string t1;
	cout&lt;&lt;&quot;输入模式串&quot;&lt;&lt;endl;
	cin&gt;&gt;t1;
	t&#x3D;t+t1;
	cout&lt;&lt;t&lt;&lt;endl;
	vector&lt;int&gt; next&#x3D;get_next(t);

	cout&lt;&lt;endl;
	cout&lt;&lt;kmp(s,t,next);
&#125;</code></pre>

<h4 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;暴力匹配
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
int match(string s,string t)&#123;
	int i&#x3D;1,j&#x3D;1,k&#x3D;1;
	while(i&lt;s.size()&amp;&amp;j&lt;t.size())&#123;
		&#x2F;&#x2F;TODO
		if(s[i]&#x3D;&#x3D;t[j])&#123;
			&#x2F;&#x2F;TODO
			i++;
			j++;
		&#125;else&#123;
			k++;
			i&#x3D;k;
			j&#x3D;1;
		&#125;
	&#125;
	if(j&gt;&#x3D;t.size())&#123;
		&#x2F;&#x2F;TODO
		return k;
	&#125;else&#123;
		return 0;
	&#125;
&#125;
int main()&#123;
	cout&lt;&lt;&quot;输入总串&quot;&lt;&lt;endl;
	string s&#x3D;&quot;#&quot;;
	string s1;
	cin&gt;&gt;s1;
	s&#x3D;s+s1;
	cout&lt;&lt;s&lt;&lt;endl;
	cout&lt;&lt;&quot;输入模式串&quot;&lt;&lt;endl;
	string t&#x3D;&quot;#&quot;;
	string t1;
	cin&gt;&gt;t1;
	t&#x3D;t+t1;
	cout&lt;&lt;t&lt;&lt;endl;
	cout&lt;&lt;match(s,t)&lt;&lt;endl;
&#125;</code></pre>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二叉树的中序遍历，递归方法
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode*left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x,struct treenode*left,struct treenode*right):data(x),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void creat(tree&amp;root)&#123;
	cout&lt;&lt;&quot;请按先序遍历输入,#表示空&quot;&lt;&lt;endl;
	string ch;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	root&#x3D;new treenode(stoi(ch));
	creat(root-&gt;left);
	creat(root-&gt;right);
&#125;
void inorder(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr) return;
	else&#123;
		inorder(root-&gt;left);
		cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
		inorder(root-&gt;right);
	&#125;

&#125;
int main()&#123;
	tree root;
	creat(root);
	inorder(root);
	return 0;
&#125;
</code></pre>

<h4 id="二叉树层次遍历"><a href="#二叉树层次遍历" class="headerlink" title="二叉树层次遍历"></a>二叉树层次遍历</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二叉树的层次遍历
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxsize 100
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
struct myque&#123;
	treenode* data[maxsize];
	int f,r,tag;
	myque():f(0),r(0),tag(0)&#123;&#125;
&#125;;
typedef struct myque myque;
bool qu_isempty(myque que)&#123;
	if(que.f&#x3D;&#x3D;que.r&amp;&amp;que.tag&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	return false;
&#125;
bool qu_isfull(myque que)&#123;
	if(que.f&#x3D;&#x3D;que.r&amp;&amp;que.tag&#x3D;&#x3D;1)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	return false;
&#125;
bool enque(treenode *&amp;root,myque&amp;q)&#123;
	if(qu_isfull(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	q.data[q.r]&#x3D;root;
	q.r&#x3D;(q.r+1)%maxsize;
	q.tag&#x3D;1;
	return true;
&#125;
bool outque(treenode *&amp;root,myque&amp;q)&#123;
	if(qu_isempty(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	root&#x3D;q.data[q.f];
	q.f&#x3D;(q.f+1)%maxsize;
	q.tag&#x3D;0;
	return true;
&#125;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;输入先序序列，#表示为空&quot;&lt;&lt;endl;
	string ch;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;else&#123;
		int data&#x3D;stoi(ch);
		root&#x3D;new treenode(data);
		create(root-&gt;left);
		create(root-&gt;right);
	&#125;
&#125;
void level(tree&amp;root)&#123;
	myque q;
	enque(root,q);
	while(!qu_isempty(q))&#123;
		&#x2F;&#x2F;TODO
		outque(root,q);
		cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
		if(root-&gt;left!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			enque(root-&gt;left,q);
		&#125;
		if(root-&gt;right!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			enque(root-&gt;right,q);
		&#125;
	&#125;

&#125;
int main()&#123;
	tree root;
	create(root);
	level(root);
&#125;</code></pre>

<h4 id="非递归求二叉树深度"><a href="#非递归求二叉树深度" class="headerlink" title="非递归求二叉树深度"></a>非递归求二叉树深度</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;非递归二叉树的深度或者高度,逐层压入，每压完一层，深度加1
#include&lt;bits&#x2F;stdc++.h&gt;
#define maxsize 100
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
struct myque&#123;
	treenode* data[maxsize];
	int f,r,tag;
	myque():f(0),r(0),tag(0)&#123;&#125;
&#125;;
typedef struct myque myque;
int volume(myque q)&#123;
	return (maxsize-(q.f-q.r))%maxsize;
&#125;
bool q_isempty(myque q)&#123;
	return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;0;
&#125;
bool q_isfull(myque q)&#123;
	return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;1;
&#125;
bool push(myque&amp;q,tree&amp;root)&#123;
	if(q_isfull(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	q.data[q.r]&#x3D;root;
	q.r&#x3D;(q.r+1)%maxsize;
	q.tag&#x3D;1;
	return true;
&#125;
bool pop(myque&amp;q,tree&amp;root)&#123;
	if(q_isempty(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	root&#x3D;q.data[q.f];
	q.f&#x3D;(q.f+1)%maxsize;
	q.tag&#x3D;0;
	return true;
&#125;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;先序序列输入，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
int depth(tree&amp;root)&#123;
	myque q;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return -1;
	&#125;
	push(q,root);
	int level&#x3D;0;
	while(!q_isempty(q))&#123;
		int temp&#x3D;volume(q);
		&#x2F;&#x2F;把当前层的结点依次弹出，然后压入它的孩子结点
		&#x2F;&#x2F;TODO
		for(int i&#x3D;0;i&lt;temp;i++)&#123;
			&#x2F;&#x2F;TODO
			pop(q,root);
			if(root-&gt;left!&#x3D;nullptr)&#123;
				&#x2F;&#x2F;TODO
				push(q,root-&gt;left);
			&#125;
			if(root-&gt;right!&#x3D;nullptr)&#123;
				&#x2F;&#x2F;TODO
				push(q,root-&gt;right);
			&#125;
		&#125;
		level++;
	&#125;
	return level;
&#125;
int main()&#123;
	tree root;
	create(root);
	cout&lt;&lt;depth(root)&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="求二叉树宽度"><a href="#求二叉树宽度" class="headerlink" title="求二叉树宽度"></a>求二叉树宽度</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;寻找二叉树的宽度，层次遍历
#include&lt;bits&#x2F;stdc++.h&gt;
#define maxsize 100
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
struct myque&#123;
	treenode* data[maxsize];
	int f,r,tag;
	myque():f(0),r(0),tag(0)&#123;&#125;
&#125;;
typedef struct myque myque;
int qsize(myque q)&#123;return (maxsize-(q.f-q.r))%maxsize;&#125;
bool q_isfull(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;1;&#125;
bool q_isempty(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;0;&#125;
bool push(myque&amp;q,tree&amp;root)&#123;
	if(q_isfull(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	q.data[q.r]&#x3D;root;
	q.r&#x3D;(q.r+1)%maxsize;
	q.tag&#x3D;1;
	return true;
&#125;
bool pop(myque&amp;q,tree&amp;root)&#123;
	if(q_isempty(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	root&#x3D;q.data[q.f];
	q.f&#x3D;(q.f+1)%maxsize;
	q.tag&#x3D;0;
	return true;
&#125;
void create(tree&amp;root)&#123;
	&#x2F;&#x2F;treenode *t&#x3D;root;
	cout&lt;&lt;&quot;先序输入，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
int width(tree &amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return 0;
	&#125;
	treenode *t&#x3D;root;
	myque q;
	push(q,t);
	int wid&#x3D;0;
	while(!q_isempty(q))&#123;
		int tempsize&#x3D;qsize(q);
		&#x2F;&#x2F;TODO
		wid&#x3D;max(wid,tempsize);

		for(int i&#x3D;1;i&lt;&#x3D;tempsize;i++)&#123;
			&#x2F;&#x2F;TODO
			pop(q,t);
			if(t-&gt;left!&#x3D;nullptr)&#123;
				&#x2F;&#x2F;TODO
				push(q,t-&gt;left);
			&#125;
			if(t-&gt;right!&#x3D;nullptr)&#123;
				&#x2F;&#x2F;TODO
				push(q,t-&gt;right);
			&#125;
		&#125;
	&#125;
	return wid;
&#125;
int main()&#123;
	tree root;
	create(root);
	cout&lt;&lt;width(root)&lt;&lt;endl;
	return 0;
&#125;</code></pre>



<h4 id="二叉排序树的判断"><a href="#二叉排序树的判断" class="headerlink" title="二叉排序树的判断"></a>二叉排序树的判断</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;判断一棵树是不是二叉排序树
&#x2F;&#x2F;中序遍历二叉树，看是不是升序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data):data(data),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data,struct treenode*left,struct treenode*right):data(data),left(left),right(right)&#123;&#125;
&#125;;
typedef vector&lt;int&gt; arr;
typedef struct treenode treenode;
typedef struct treenode* tree;
void creat_tree(tree&amp;root)&#123;
	cout&lt;&lt;&quot;请按先序输入，#表示空&quot;&lt;&lt;endl;
	string ch;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;else&#123;
		int data&#x3D;stoi(ch);
		root&#x3D;new treenode(data);
		creat_tree(root-&gt;left);
		creat_tree(root-&gt;right);
	&#125;
&#125;
void inorder(tree&amp;root,arr&amp;a)&#123;
	stack&lt;treenode*&gt;stree;
	while(root!&#x3D;nullptr||!stree.empty())&#123;
		&#x2F;&#x2F;TODO
		while(root!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			stree.push(root);
			root&#x3D;root-&gt;left;
		&#125;
		root&#x3D;stree.top();
		stree.pop();
		a.push_back(root-&gt;data);
		root&#x3D;root-&gt;right;
	&#125;


&#125;
int main()&#123;
	arr a;
	treenode *root;
	creat_tree(root);
	inorder(root,a);
	cout&lt;&lt;is_sorted(a.begin(),a.end());
	return 0;
&#125;
&#x2F;&#x2F;方法二
bool isValidBST(TreeNode* root) &#123;
        &#x2F;&#x2F;非递归中序遍历确保有序
        long long int predata&#x3D;(long long)INT_MIN-1;
        stack&lt;TreeNode*&gt; mystack;
        while(root!&#x3D;nullptr||!mystack.empty())&#123;
            while(root!&#x3D;nullptr)&#123;
                mystack.push(root);
                root&#x3D;root-&gt;left;
            &#125;
            root&#x3D;mystack.top();
            mystack.pop();
            if(root-&gt;val&lt;&#x3D;predata)&#123;return false;&#125;&#x2F;&#x2F;和前者作比较
            predata&#x3D;root-&gt;val;&#x2F;&#x2F;储存值
            root&#x3D;root-&gt;right;

        &#125;
        return true;
    &#125;
</code></pre>

<h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
        if (t1 &#x3D;&#x3D; nullptr) &#123;
            return t2;
        &#125;
        if (t2 &#x3D;&#x3D; nullptr) &#123;
            return t1;
        &#125;
        auto merged &#x3D; new TreeNode(t1-&gt;val + t2-&gt;val);
        merged-&gt;left &#x3D; mergeTrees(t1-&gt;left, t2-&gt;left);
        merged-&gt;right &#x3D; mergeTrees(t1-&gt;right, t2-&gt;right);
        return merged;
    &#125;
&#125;;</code></pre>

<h4 id="二叉树第二小结点"><a href="#二叉树第二小结点" class="headerlink" title="二叉树第二小结点"></a>二叉树第二小结点</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findSecondMinimumValue(TreeNode* root) &#123;
        if(!root || !root-&gt;left || !root-&gt;right) return -1;&#x2F;&#x2F;空节点或不满足题意
        
        int left&#x3D;root-&gt;left-&gt;val,right&#x3D;root-&gt;right-&gt;val;
        
        &#x2F;&#x2F;若根节点和左节点值相同，则递归找左子树的第二小节点
        if(root-&gt;val&#x3D;&#x3D;root-&gt;left-&gt;val) left&#x3D;findSecondMinimumValue(root-&gt;left);
        &#x2F;&#x2F;若根节点和右节点值相同，则递归找右子树的第二小节点
        if(root-&gt;val&#x3D;&#x3D;root-&gt;right-&gt;val) right&#x3D;findSecondMinimumValue(root-&gt;right);

        &#x2F;&#x2F;若根节点等于左右子树的第二小节点返回-1
        if(root-&gt;val&#x3D;&#x3D;left &amp;&amp; root-&gt;val&#x3D;&#x3D;right) return -1;

        &#x2F;&#x2F;根据当前的根、左右节点的值继续判断
        int min_lr&#x3D;min(left,right);
        if(root-&gt;val&lt;min_lr) return min_lr;&#x2F;&#x2F;根节点小于最小值，返回最小值
        else return max(left,right);&#x2F;&#x2F;根节点与子树的值相等，第二小只能是比最小的还要大
    &#125;

&#125;;</code></pre>

<h4 id="判断结点是不是堂兄弟"><a href="#判断结点是不是堂兄弟" class="headerlink" title="判断结点是不是堂兄弟"></a>判断结点是不是堂兄弟</h4><pre class="language-c++" data-language="c++"><code class="language-c++">bool iscousn(tree&amp;root,int x,int y)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	myque q;
	pushq(q,root);
	bool flag1&#x3D;false;
	while(!qisempty(q))&#123;
		&#x2F;&#x2F;TODO
		int volume&#x3D;qsize(q);
		int i&#x3D;0;
		while(i&lt;volume)&#123;
			&#x2F;&#x2F;TODO
			popq(q,root);
			if(root-&gt;left!&#x3D;nullptr)&#123;
				&#x2F;&#x2F;TODO
				pushq(q,root-&gt;left);
			&#125;
			if(root-&gt;right!&#x3D;nullptr)&#123;
				&#x2F;&#x2F;TODO
				pushq(q,root-&gt;right);
			&#125;
			if(root!&#x3D;nullptr&amp;&amp;root-&gt;data&#x3D;&#x3D;x)&#123;
				&#x2F;&#x2F;TODO
				flag1&#x3D;true;
				
			&#125;
			if(flag1&#x3D;&#x3D;true&amp;&amp;root-&gt;data&#x3D;&#x3D;y)&#123;
				&#x2F;&#x2F;TODO
				return true;
			&#125;
			i++;
		&#125;
	&#125;
	return false;
&#125;</code></pre>

<h4 id="非递归后序遍历求叶子结点路径"><a href="#非递归后序遍历求叶子结点路径" class="headerlink" title="非递归后序遍历求叶子结点路径"></a>非递归后序遍历求叶子结点路径</h4><pre class="language-c++" data-language="c++"><code class="language-c++">void findpath(tree&amp;root)&#123;
	myt sta[100];
	int top&#x3D;0;
	while(root!&#x3D;nullptr||top&gt;0)&#123;
		&#x2F;&#x2F;TODO
		while(root!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			top++;
			sta[top].root&#x3D;root;
			sta[top].tag&#x3D;0;&#x2F;&#x2F;表示左节点已经访问过
			
			root&#x3D;root-&gt;left;
		&#125;
		&#x2F;&#x2F;此时跳出循环应该是遇到叶子结点的空结点，栈顶肯定是叶子结点
		cout&lt;&lt;sta[top].root-&gt;data&lt;&lt;&quot;的路径是&quot;&lt;&lt;endl;
		int i&#x3D;1;
		while(i&lt;&#x3D;top)&#123;
			&#x2F;&#x2F;TODO
			cout&lt;&lt;sta[i].root-&gt;data&lt;&lt;&quot; &quot;;
			i++;
		&#125;
		&#x2F;&#x2F;弹出已经访问过右节点的结点
		while(top&gt;0&amp;&amp;sta[top].tag&#x3D;&#x3D;1)&#123;
			&#x2F;&#x2F;TODO
			top--;
		&#125;
		if(top&gt;0)&#123;
			&#x2F;&#x2F;TODO
			sta[top].tag&#x3D;1;
			root&#x3D;sta[top].root-&gt;right;
		&#125;
	&#125;
	
	
&#125;</code></pre>

<h4 id="二叉排序树调整"><a href="#二叉排序树调整" class="headerlink" title="二叉排序树调整"></a>二叉排序树调整</h4><pre class="language-c++" data-language="c++"><code class="language-c++">void inorder(tree &amp;root)&#123;
        if(root) &#123;
            inorder(root-&gt;left);
            temp.push_back(root-&gt;val);
            inorder(root-&gt;right);
        &#125;
        
    &#125;
&#x2F;&#x2F;中序遍历储存数值
    void inorder_change(tree &amp;root,vector&lt;int&gt; &amp;temp)&#123;
        if(root)&#123;
            inorder_change(root-&gt;left,temp);
            root-&gt;val&#x3D;temp[cnt];
            cnt++;
            cout&lt;&lt;root-&gt;val&lt;&lt;endl;
            inorder_change(root-&gt;right,temp);    
        
        &#125; 
        
        
    &#125;
&#x2F;&#x2F;中序重新创建二叉树
    void recoverTree(TreeNode* root) &#123;
        inorder(root);
     
        sort(temp.begin(),temp.end());&#x2F;&#x2F;排序然后重新遍历root，进行修改
        for(int num:temp)&#123;cout&lt;&lt;num;&#125;
        cout&lt;&lt;endl;
        inorder_change(root,temp);
        
    &#125;</code></pre>

<h4 id="寻找二叉树相同子树序列"><a href="#寻找二叉树相同子树序列" class="headerlink" title="寻找二叉树相同子树序列"></a>寻找二叉树相同子树序列</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二叉树的序列化，判断是否有相同子树，从最底层开始往上找，所以需要深度优先遍历
&#x2F;&#x2F;深度优先遍历这里采用先序遍历，然后从底到高记录下序列，每次加入序列就检查是否有重复序列出现
typedef struct TreeNode* tree;

    vector&lt;TreeNode*&gt; res;
    unordered_map&lt;string,int&gt;map;
    &#x2F;&#x2F;int res&#x3D;0;
    string dfs(tree&amp;root,unordered_map&lt;string,int&gt;&amp;map,vector&lt;TreeNode*&gt;&amp;res)&#123;
        if(root&#x3D;&#x3D;nullptr) return &quot;&quot;;
        string str&#x3D;to_string(root-&gt;val)+&quot;,&quot;+dfs(root-&gt;left,map,res)+&quot;,&quot;+dfs(root-&gt;right,map,res);
        if(map[str]&#x3D;&#x3D;1)&#123;
            res.push_back(root);
        &#125;
        map[str]++;
        return str;
    &#125;
    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;
        dfs(root,map,res);
        return res;
    &#125;</code></pre>

<h4 id="二叉树最长同值路径"><a href="#二叉树最长同值路径" class="headerlink" title="二叉树最长同值路径"></a>二叉树最长同值路径</h4><pre class="language-c++" data-language="c++"><code class="language-c++">public:
	&#x2F;&#x2F;递归看，同值路径必须要经过每一个根
    int res&#x3D;0;

    int dfs(tree&amp;root)&#123;
        if(root&#x3D;&#x3D;nullptr) return 0;
        int left&#x3D;0,right&#x3D;0;
        int leftend&#x3D;0,rightend&#x3D;0;
        left&#x3D;dfs(root-&gt;left);
        right&#x3D;dfs(root-&gt;right);
        if(root-&gt;left!&#x3D;nullptr&amp;&amp;root-&gt;val&#x3D;&#x3D;root-&gt;left-&gt;val)&#123;
            leftend&#x3D;left+1;
        &#125;
        if(root-&gt;right!&#x3D;nullptr&amp;&amp;root-&gt;right-&gt;val&#x3D;&#x3D;root-&gt;val)&#123;
            rightend&#x3D;right+1;
        &#125;

        res&#x3D;max(res,leftend+rightend);
        return max(leftend,rightend);
    &#125;
    int longestUnivaluePath(TreeNode* root) &#123;
        &#x2F;&#x2F;最长同值路径也是采用递归思想
        &#x2F;&#x2F;去看左子树的最大同值路径，右子树的最大同直路径，
        &#x2F;&#x2F;然后看与根值是否相同，左边相同左边+1，否则就归0
        dfs(root);
        return res;

    &#125;</code></pre>

<h4 id="左右子树交换是否满足先序序列"><a href="#左右子树交换是否满足先序序列" class="headerlink" title="左右子树交换是否满足先序序列"></a>左右子树交换是否满足先序序列</h4><pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; res;
    int i&#x3D;0;
    bool dfs(tree&amp;root,vector&lt;int&gt;&amp;voyage)&#123;
        if(root&#x3D;&#x3D;nullptr) return true;
        if(root-&gt;val!&#x3D;voyage[i]) return false;
        i++;
        if(dfs(root-&gt;left,voyage)&amp;&amp;dfs(root-&gt;right,voyage))&#123;
            return true;
        &#125;
        if(dfs(root-&gt;right,voyage)&amp;&amp;dfs(root-&gt;left,voyage))&#123;
            res.push_back(root-&gt;val);
            return true;
        &#125;
        return false;
    &#125;
    vector&lt;int&gt; flipMatchVoyage(TreeNode* root, vector&lt;int&gt;&amp; voyage) &#123;
        if(dfs(root,voyage))&#123;
            return res;
        &#125;
        res.erase(res.begin(),res.end());
        res.push_back(-1);
        return res;
    &#125;</code></pre>

<h4 id="后序遍历删除特定叶子结点"><a href="#后序遍历删除特定叶子结点" class="headerlink" title="后序遍历删除特定叶子结点"></a>后序遍历删除特定叶子结点</h4><pre class="language-c++" data-language="c++"><code class="language-c++">TreeNode* removeLeafNodes(TreeNode* root, int target) &#123;
        if(root&#x3D;&#x3D;nullptr) return nullptr;
        root-&gt;left&#x3D;removeLeafNodes(root-&gt;left,target);
        root-&gt;right&#x3D;removeLeafNodes(root-&gt;right,target);
        if(root-&gt;left&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;right&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;val&#x3D;&#x3D;target)&#123;
            return nullptr;
        &#125;
        return root;

    &#125;</code></pre>

<h4 id="二叉搜索树删除结点并调整"><a href="#二叉搜索树删除结点并调整" class="headerlink" title="二叉搜索树删除结点并调整"></a>二叉搜索树删除结点并调整</h4><pre class="language-c++" data-language="c++"><code class="language-c++">TreeNode* deleteNode(TreeNode* root, int key) &#123;
        if(root&#x3D;&#x3D;nullptr) return nullptr;
        if(key&gt;root-&gt;val)&#123;
            root-&gt;right&#x3D;deleteNode(root-&gt;right,key);
        &#125;
        else if(key&lt;root-&gt;val)&#123;
            root-&gt;left&#x3D;deleteNode(root-&gt;left,key);
        &#125;
        else&#123;
            if(root-&gt;left&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;right&#x3D;&#x3D;nullptr) return nullptr;
            if(root-&gt;left&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;right!&#x3D;nullptr) return root-&gt;right;
            if(root-&gt;right&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;left!&#x3D;nullptr) return root-&gt;left;
            if(root-&gt;left!&#x3D;nullptr&amp;&amp;root-&gt;right!&#x3D;nullptr)&#123;
                TreeNode *node&#x3D;root-&gt;right;
                while(node-&gt;left!&#x3D;nullptr)&#123;
                    node&#x3D;node-&gt;left;
                &#125;
                node-&gt;left&#x3D;root-&gt;left;
                root&#x3D;root-&gt;right;
                
            &#125;

        &#125;
        return root;
    ｝</code></pre>

<h4 id="寻找结点最大乘积"><a href="#寻找结点最大乘积" class="headerlink" title="寻找结点最大乘积"></a>寻找结点最大乘积</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;实现两个数的最大乘积，和一定，那么最大乘积一定是两数平分，所以，
&#x2F;&#x2F;只有当分出的数越接近、sum的一半乘积越大
typedef struct TreeNode treenode;
typedef struct TreeNode* tree;
class Solution &#123;
public:
    int sum&#x3D;0;
    int partnum&#x3D;0;
    int partsum&#x3D;0;
    void dfs(tree&amp;root)&#123;
        if(root!&#x3D;nullptr)&#123;
            sum+&#x3D;root-&gt;val;
            dfs(root-&gt;left);
            dfs(root-&gt;right);
        &#125;
    &#125;
    int findpart(tree&amp;root)&#123;
        if(root&#x3D;&#x3D;nullptr) return 0;
        else&#123;
            partsum&#x3D;root-&gt;val+findpart(root-&gt;left)+findpart(root-&gt;right);
        
            if(abs(2*partsum-sum)&lt;abs(2*partnum-sum))&#123;
            partnum&#x3D;partsum;
            &#125;
        
            return partsum;

        &#125;
    &#125;
    int maxProduct(TreeNode* root) &#123;
        dfs(root);
        findpart(root);
        cout&lt;&lt;sum;
        return ((unsigned long)partnum * (sum-partnum)) % 1000000007;

    &#125;
&#125;;</code></pre>

<h4 id="判断二叉树是否对称"><a href="#判断二叉树是否对称" class="headerlink" title="判断二叉树是否对称"></a>判断二叉树是否对称</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;判断一棵树是不是对称树
&#x2F;&#x2F;看左子树的左子树与右子树的右子树是否相等
&#x2F;&#x2F;看左子树的右子树与右子树的左子树是否相等
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data):data(data),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data,struct treenode*left,struct treenode*right):data(data),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void creat_tree(tree&amp;root)&#123;
	cout&lt;&lt;&quot;请输入每个结点,#表示空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;else&#123;
		int data&#x3D;stoi(str);
		root&#x3D;new treenode(data);
		creat_tree(root-&gt;left);
		creat_tree(root-&gt;right);
	&#125;
&#125;
bool is_symmetry(treenode *p,treenode *q)&#123;
	if(q&#x3D;&#x3D;nullptr&amp;&amp;p&#x3D;&#x3D;nullptr) return true;&#x2F;&#x2F;两节点都为空
	else if(q&#x3D;&#x3D;nullptr||p&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;else&#123;
		return p-&gt;data&#x3D;&#x3D;q-&gt;data&amp;&amp;is_symmetry(p-&gt;left,q-&gt;right)&amp;&amp;is_symmetry(p-&gt;right,q-&gt;left);
	&#125;
&#125;
int main()&#123;
	treenode *root;
	creat_tree(root);
	bool res&#x3D; is_symmetry(root,root);
	cout&lt;&lt;res&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="二叉树结构是否相同"><a href="#二叉树结构是否相同" class="headerlink" title="二叉树结构是否相同"></a>二叉树结构是否相同</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;判断两棵树是否相同
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode*left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data):data(data),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int data,struct treenode*left,struct treenode*right):data(data),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void creat_tree(tree&amp;root)&#123;
	cout&lt;&lt;&quot;请按先序遍历输入，输入#表示结点为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		root&#x3D;nullptr;
		return;
	&#125;
	root&#x3D;new treenode(stoi(str));
	creat_tree(root-&gt;left);
	creat_tree(root-&gt;right);

&#125;
bool is_same_tree(tree&amp;tr1,tree&amp;tr2)&#123;
	if(tr1&#x3D;&#x3D;nullptr&amp;&amp;tr2&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;else if(tr1&#x3D;&#x3D;nullptr||tr2&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;else if(tr1-&gt;data!&#x3D;tr2-&gt;data)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;else&#123;
		&#x2F;&#x2F;两个结点相等后，继续深度遍历判断
		return is_same_tree(tr1-&gt;left,tr2-&gt;left)&amp;&amp;is_same_tree(tr1-&gt;right,tr2-&gt;right);
	&#125;
&#125;
int main()&#123;
	tree tr1;
	tree tr2;
	creat_tree(tr1);
	cout&lt;&lt;&quot;请输入第二棵树&quot;&lt;&lt;endl;
	creat_tree(tr2);
	cout&lt;&lt;is_same_tree(tr1,tr2);
	return 0;
&#125;</code></pre>

<h4 id="平衡二叉树的判断"><a href="#平衡二叉树的判断" class="headerlink" title="平衡二叉树的判断"></a>平衡二叉树的判断</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;判断平衡二叉树
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x,struct treenode *left,struct treenode *right):data(x),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create_tree(tree&amp;root)&#123;
	&#x2F;&#x2F;先序方式创建
	cout&lt;&lt;&quot;请输入结点值,#表示空&quot;&lt;&lt;endl;
	string ch;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;else&#123;
		int data&#x3D;stoi(ch);
		root&#x3D;new treenode(data);
		create_tree(root-&gt;left);
		create_tree(root-&gt;right);
	&#125;

&#125;
int depth(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return 0;
	&#125;else&#123;
		return max(depth(root-&gt;left),depth(root-&gt;right))+1;
	&#125;
&#125;
bool is_balanced(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO,空树也是平衡树
		return true;
	&#125;else&#123;
		&#x2F;&#x2F;递归判断
		return abs(depth(root-&gt;left)-depth(root-&gt;right))&lt;&#x3D;1 &amp;&amp; is_balanced(root-&gt;left) &amp;&amp; is_balanced(root-&gt;right);
	&#125;
&#125;
int main()&#123;
	tree root;
	create_tree(root);
	cout&lt;&lt;is_balanced(root)&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="求二叉树最小深度"><a href="#求二叉树最小深度" class="headerlink" title="求二叉树最小深度"></a>求二叉树最小深度</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;求二叉树的最小深度
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x,struct treenode *left,struct treenode *right):data(x),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create_tree(tree&amp;root)&#123;
	cout&lt;&lt;&quot;请按先序顺序输入，#表示为空&quot;&lt;&lt;endl;
	string ch;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;else&#123;
		int data&#x3D;stoi(ch);
		root&#x3D;new treenode(data);
		create_tree(root-&gt;left);
		create_tree(root-&gt;right);
	&#125;
&#125;
int min_depth(tree&amp;root)&#123;
	int min_depth_recur&#x3D;INT_MAX;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return 0;
	&#125;
	if(root-&gt;left&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;right&#x3D;&#x3D;nullptr)&#123;
		return 1;&#x2F;&#x2F;此时root是叶子结点
		&#x2F;&#x2F;TODO
	&#125;&#x2F;&#x2F;不是叶子结点开始递归

	else&#123;

		if(root-&gt;left!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			min_depth_recur&#x3D;min(min_depth(root-&gt;left),min_depth_recur);
		&#125;
		&#x2F;&#x2F;这么写if是避免了漏掉左子树为空，右子树不为空的
		if(root-&gt;right!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			min_depth_recur&#x3D;min(min_depth(root-&gt;right),min_depth_recur);
		&#125;

	&#125;
	return min_depth_recur+1;
&#125;
int main()&#123;
	tree root;
	create_tree(root);
	cout&lt;&lt;min_depth(root)&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="特定路径总和"><a href="#特定路径总和" class="headerlink" title="特定路径总和"></a>特定路径总和</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;路径总和
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x,struct treenode*left,struct treenode*right):data(x),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create_tree(tree&amp;root)&#123;
	cout&lt;&lt;&quot;请按先序输入，#表示为空&quot;&lt;&lt;endl;
	string ch;
	cin&gt;&gt;ch;
	if(ch&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;else&#123;
		int data&#x3D;stoi(ch);
		root&#x3D;new treenode(data);
		create_tree(root-&gt;left);
		create_tree(root-&gt;right);
	&#125;
&#125;
bool sum_path(tree&amp;root,int sum)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	if(root-&gt;left&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;right&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;data&#x3D;&#x3D;sum)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	return sum_path(root-&gt;left,sum-root-&gt;data)||sum_path(root-&gt;right,sum-root-&gt;data);
&#125;
int main()&#123;
	tree root;
	create_tree(root);
	cout&lt;&lt;sum_path(root,4)&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="有序数组转换为二叉树"><a href="#有序数组转换为二叉树" class="headerlink" title="有序数组转换为二叉树"></a>有序数组转换为二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;有序数组转化位二叉搜索树
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left,*right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x,struct treenode*left,struct treenode*right):data(x),left(left),right(right)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
typedef vector&lt;int&gt; arr;
treenode* create_search(arr&amp;num,int left,int right)&#123;
	if(left&lt;0||right&gt;num.size()||left&gt;right)&#123;
		&#x2F;&#x2F;TODO
		return nullptr;
	&#125;
	&#x2F;&#x2F;递归出口
	if(left&#x3D;&#x3D;right)&#123;
		&#x2F;&#x2F;TODO
		return new treenode(num[left]);
	&#125;
	int mid&#x3D;(left+right)&#x2F;2;
	treenode *root&#x3D;new treenode(num[mid]);&#x2F;&#x2F;创建结点
	&#x2F;&#x2F;继续递归
	root-&gt;left&#x3D;create_search(num,left,mid-1);
	root-&gt;right&#x3D;create_search(num,mid+1,right);
	return root;
&#125;
&#x2F;&#x2F;先序遍历
void print(tree&amp;root)
&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return ;
	&#125;
	cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
	print(root-&gt;left);
	print(root-&gt;right);
&#125;

int main()&#123;
	arr a&#123;1,2,3,4,5,6,7,8,9&#125;;
	int left&#x3D;0,right&#x3D;a.size()-1;
	treenode *test&#x3D;create_search(a,left,right);
	print(test);
	return 0;

&#125;</code></pre>

<h4 id="二叉排序树解决TOP-K问题"><a href="#二叉排序树解决TOP-K问题" class="headerlink" title="二叉排序树解决TOP-K问题"></a>二叉排序树解决TOP-K问题</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二叉搜索树找到第k小个元素
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	int count;&#x2F;&#x2F;这里的count包含根节点，所以初始化时赋值1
	treenode():data(-1),left(nullptr),right(nullptr),count(1)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr),count(1)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
typedef vector&lt;int&gt; myarray;
myarray test&#123;78,56,100,34,120,399,32&#125;;
void insert_node(tree&amp;root,int data)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;new treenode(data);
		return;
	&#125;
	if(root-&gt;data&#x3D;&#x3D;data)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;数值已存在无法插入&quot;&lt;&lt;endl;
		return;
	&#125;
	else if(root-&gt;data&lt;data)&#123;
		&#x2F;&#x2F;TODO
		root-&gt;count++;
		insert_node(root-&gt;right,data);
	&#125;
	else&#123;
		root-&gt;count++;
		insert_node(root-&gt;left,data);
	&#125;
&#125;
void create(tree&amp;root,myarray test)&#123;
	int i&#x3D;0;
	while(i&lt;test.size())&#123;
		&#x2F;&#x2F;TODO
		insert_node(root,test[i]);
		i++;
	&#125;
&#125;
int findnum(tree&amp;root,int k)&#123;
	if(k&lt;1||k&gt;root-&gt;count) return -1;
	if(root-&gt;left&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;左子树为空，第k小去右子树找，
		if(k&#x3D;&#x3D;1)&#123;
			&#x2F;&#x2F;TODO，根节点
			return root-&gt;data;
		&#125;
		return findnum(root-&gt;right,k-1);&#x2F;&#x2F;从上往下找，直到k减为1，就是第k小
	&#125;
	else&#123;
		if(root-&gt;left-&gt;count&#x3D;&#x3D;k-1)&#123;
			&#x2F;&#x2F;TODO
			return root-&gt;data;
		&#125;
		if(root-&gt;left-&gt;count&gt;k-1)&#123;
			&#x2F;&#x2F;TODO
			return findnum(root-&gt;left,k);&#x2F;&#x2F;这里不用减一
		&#125;
		if(root-&gt;left-&gt;count&lt;k-1)&#123;
			&#x2F;&#x2F;先执行上面的if,然后count不断减小，再来执行这个if
			return findnum(root-&gt;right,k-(root-&gt;left-&gt;count+1));
		&#125;
	&#125;
&#125;
int main()&#123;
	tree root;
	create(root,test);
	cout&lt;&lt;findnum(root,2);
	return 0;
&#125;</code></pre>

<h4 id="层次遍历判断完全二叉树"><a href="#层次遍历判断完全二叉树" class="headerlink" title="层次遍历判断完全二叉树"></a>层次遍历判断完全二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;层序遍历解决完全二叉树的判定
#include&lt;bits&#x2F;stdc++.h&gt;
#define maxsize 100
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
struct myque&#123;
	treenode* data[maxsize];
	int f,r,tag;
	myque():f(0),r(0),tag(0)&#123;&#125;
&#125;;
typedef struct myque myque;
int qsize(myque q)&#123;return (maxsize-(q.f-q.r))%maxsize;&#125;
bool qisfull(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;1;&#125;
bool qisempty(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;0;&#125;
bool pushq(myque&amp;q,treenode* root)&#123;
	if(qisfull(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	q.data[q.r]&#x3D;root;
	q.r&#x3D;(q.r+1)%maxsize;
	return true;
&#125;
bool popq(myque&amp;q,tree&amp;root)&#123;
	if(qisempty(q))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	root&#x3D;q.data[q.f];
	q.f&#x3D;(q.f+1)%maxsize;
&#125;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;先序树，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
void display(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
	display(root-&gt;left);
	display(root-&gt;right);
&#125;
bool level_bianli(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	myque q;
	pushq(q,root);
	while(!qisempty(q))&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;当遇到空结点时，不断出队，只要由非空结点，就说明不是完全二叉树
		popq(q,root);
		if(root!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			pushq(q,root-&gt;left);
			pushq(q,root-&gt;right);
		&#125;else&#123;
			&#x2F;&#x2F;遇到空结点，后面应该都是空结点
			while(!qisempty(q))&#123;
				&#x2F;&#x2F;TODO
				popq(q,root);
				if(root!&#x3D;nullptr)&#123;
					&#x2F;&#x2F;TODO
					return false;
				&#125;
			&#125;
		&#125;

	&#125;
	return true;
&#125;
int main()&#123;
	tree root;
	create(root);
	display(root);
	cout&lt;&lt;endl;
	cout&lt;&lt;level_bianli(root);
	return 0;
&#125;</code></pre>

<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建线索二叉树
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct threadnode&#123;
	int data;
	struct threadnode *left;
	struct threadnode *right;
	int ltag;
	int rtag;
	threadnode():data(-1),left(nullptr),right(nullptr),ltag(0),rtag(0)&#123;&#125;
	threadnode(int x):data(x),left(nullptr),right(nullptr),ltag(0),rtag(0)&#123;&#125;
&#125;;
typedef struct threadnode threadnode;
typedef struct threadnode* threadtree;
&#x2F;&#x2F;先创建出树才能线索化
threadnode *pre&#x3D;nullptr;
void createtree(threadtree&amp;root)&#123;
	cout&lt;&lt;&quot;先序遍历顺序输入，#表示空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
	&#125;else&#123;
		int data&#x3D;stoi(str);
		root&#x3D;new threadnode(data);
		createtree(root-&gt;left);
		createtree(root-&gt;right);
	&#125;

&#125;
void visit(threadtree&amp;root)&#123;
	&#x2F;&#x2F;当前结点的左子树为空，要么前驱结点的右子树为空，只有这两种情况
	&#x2F;&#x2F;中序遍历线索化，只有最后没有孩子了，前驱和后继才能赋值
	&#x2F;&#x2F;助记，中序线索化，就是为了找前驱，当前结点左子树为空，才能赋值前驱
	if(root-&gt;left&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		root-&gt;left&#x3D;pre;
		root-&gt;ltag&#x3D;1;
	&#125;
	if(pre!&#x3D;nullptr&amp;&amp;pre-&gt;right&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		pre-&gt;right&#x3D;root;
		pre-&gt;rtag&#x3D;1;
	&#125;
	pre&#x3D;root;
&#125;
void vesttree(threadtree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;else&#123;
		vesttree(root-&gt;left);
		visit(root);
		vesttree(root-&gt;right);
	&#125;

&#125;
void create_threadtree(threadtree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	else&#123;
		vesttree(root);
		if(pre-&gt;right&#x3D;&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			pre-&gt;rtag&#x3D;1;
		&#125;
	&#125;

&#125;
void bianli(threadtree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;else&#123;

		cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;root-&gt;ltag&lt;&lt;&quot; &quot;&lt;&lt;root-&gt;rtag&lt;&lt;endl;
		if(root-&gt;ltag&#x3D;&#x3D;0)&#123;
			bianli(root-&gt;left);
		&#125;
		if(root-&gt;rtag&#x3D;&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			bianli(root-&gt;right);
		&#125;

	&#125;
&#125;
&#x2F;&#x2F;寻找子树的第一个结点
threadnode* firstnode(threadtree&amp;root)&#123;
	while(root-&gt;ltag&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;root-&gt;left;
	&#125;
	return root;
&#125;
&#x2F;&#x2F;寻找某个结点的后继，就是寻找这个结点右子树的第一个结点
threadnode* nextnode(threadtree&amp;root)&#123;
	if(root-&gt;rtag&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		return firstnode(root-&gt;right);
	&#125;
	return root-&gt;right;
&#125;
void real_bianli(threadtree&amp;root)&#123;
	for(threadnode *p&#x3D;firstnode(root);p!&#x3D;nullptr;p&#x3D;nextnode(p))&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;
	&#125;
&#125;
&#x2F;&#x2F;找子树的最后一个结点，就是找子树的最右边的结点
threadnode* lastnode(threadtree&amp;root)&#123;
	while(root-&gt;rtag&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;root-&gt;right;
	&#125;
	return root;
&#125;
&#x2F;&#x2F;找前驱就是找左子树的最后一个结点
threadnode* prenode(threadtree&amp;root)&#123;
	if(root-&gt;ltag&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		return lastnode(root-&gt;left);
	&#125;
	return root-&gt;left;
&#125;
void real_bianli2(threadtree&amp;root)&#123;
	for(threadnode *p&#x3D;lastnode(root);p!&#x3D;nullptr;p&#x3D;prenode(p))&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;
	&#125;
&#125;
int main()&#123;
	threadtree root;
	createtree(root);
	create_threadtree(root);
	bianli(root);&#x2F;&#x2F;直接遍历会成环
	real_bianli(root);
	cout&lt;&lt;endl;
	cout&lt;&lt;root-&gt;data&lt;&lt;endl;
	real_bianli2(root);
	return 0;
&#125;</code></pre>

<h4 id="从左到右结点串成串"><a href="#从左到右结点串成串" class="headerlink" title="从左到右结点串成串"></a>从左到右结点串成串</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;中序遍历将叶子结点串成串
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxsize 100
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
struct mystack&#123;
	treenode* data[maxsize];
	int top;
	mystack():top(-1)&#123;&#125;
&#125;;
struct listnode&#123;
	int data;
	struct treenode *next;
	listnode():data(-1),next(nullptr)&#123;&#125;
&#125;;
typedef struct listnode listnode;
typedef struct mystack mystack;
bool s_isempty(mystack s)&#123;return s.top&#x3D;&#x3D;-1;&#125;
bool s_isfull(mystack s)&#123;return s.top&#x3D;&#x3D;maxsize-1;&#125;
bool spush(mystack&amp;s,tree&amp;root)&#123;
	if(s_isfull(s))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	s.top++;
	s.data[s.top]&#x3D;root;
	return true;
&#125;
bool spop(mystack&amp;s,tree&amp;root)&#123;
	if(s_isempty(s))&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;
	root&#x3D;s.data[s.top];
	s.top--;
	return true;
&#125;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;输入先序序列，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);

&#125;
mystack s;
listnode *p_head&#x3D;new listnode();
void lis(tree&amp;root)&#123;
	treenode *temp;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	&#x2F;&#x2F;不断向左遍历，直到找到最左边的叶子结点
	lis(root-&gt;left);
	if(root-&gt;left&#x3D;&#x3D;nullptr&amp;&amp;root-&gt;right&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		if(s_isempty(s))&#123;
			&#x2F;&#x2F;TODO
			p_head-&gt;next&#x3D;root;
			spush(s,root);
		&#125;else&#123;
			spop(s,temp);
			temp-&gt;right&#x3D;root;
			spush(s,root);
		&#125;
	&#125;
	lis(root-&gt;right);

&#125;
int main()&#123;
	tree root;
	create(root);
	lis(root);
	root&#x3D;p_head-&gt;next;
	while(root!&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
		root&#x3D;root-&gt;right;

	&#125;
	return 0;
&#125;</code></pre>

<h4 id="判断两树相似"><a href="#判断两树相似" class="headerlink" title="判断两树相似"></a>判断两树相似</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;递归判断两树相似
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;先序输入，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
bool is_similar(tree&amp;root1,tree&amp;root2)&#123;
	if(root1&#x3D;&#x3D;nullptr&amp;&amp;root2&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;
	else if(root1&#x3D;&#x3D;nullptr||root2&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return false;
	&#125;else&#123;
		return is_similar(root1-&gt;left,root2-&gt;left)&amp;&amp;is_similar(root1-&gt;right,root2-&gt;right);
	&#125;
&#125;
int main()&#123;
	tree root1;
	tree root2;
	cout&lt;&lt;&quot;第一棵树&quot;&lt;&lt;endl;
	create(root1);
	cout&lt;&lt;&quot;第二棵树&quot;&lt;&lt;endl;
	create(root2);
	if(is_similar(root1,root2))&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;相似&quot;&lt;&lt;endl;
	&#125;else&#123;cout&lt;&lt;&quot;不相似&quot;&lt;&lt;endl;&#125;
	return 0;
&#125;</code></pre>

<h4 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;寻找二叉树的最近公共祖先
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;按先序序列输入，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
treenode* ancestor(tree&amp;root,int p,int q)&#123;
	&#x2F;&#x2F;不断递归，无论那一层，当p,q,出现在根节点上
	if(root&#x3D;&#x3D;nullptr||root-&gt;data&#x3D;&#x3D;p||root-&gt;data&#x3D;&#x3D;q)&#123;
		return root;&#x2F;&#x2F;从上往下递归，每一层都先看，每一层的root,是不是这两个数，才往下递归
	&#125;
	&#x2F;&#x2F;说明根不是这两个，开始分别去左子树和右子树看
	treenode* lef&#x3D;ancestor(root-&gt;left,p,q);
	treenode* righ&#x3D;ancestor(root-&gt;right,p,q);
	if(lef&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO说明，没有找到这两个中的任一个
		return righ;
	&#125;
	if(righ&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return lef;
	&#125;
	&#x2F;&#x2F;都找到说明，在两个分支上
	return root;&#x2F;&#x2F;就将这一层的root返回
&#125;
int main()&#123;
	tree root;
	create(root);
	int p,q;
	cout&lt;&lt;&quot;输入p,q&quot;&lt;&lt;endl;
	cin&gt;&gt;p&gt;&gt;q;
	root&#x3D;ancestor(root,p,q);
	cout&lt;&lt;root-&gt;data&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="孩子兄弟表示法计算叶子结点个数"><a href="#孩子兄弟表示法计算叶子结点个数" class="headerlink" title="孩子兄弟表示法计算叶子结点个数"></a>孩子兄弟表示法计算叶子结点个数</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;先序输入，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
int leaves(tree&amp;root)&#123;

	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return 0;
	&#125;
	if(root-&gt;left&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return 1+leaves(root-&gt;right);
	&#125;
	else&#123;
		return leaves(root-&gt;left)+leaves(root-&gt;right);
	&#125;
&#125;
int main()&#123;
	tree root;
	create(root);
	cout&lt;&lt;leaves(root)&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="孩子兄弟表示法求树深度"><a href="#孩子兄弟表示法求树深度" class="headerlink" title="孩子兄弟表示法求树深度"></a>孩子兄弟表示法求树深度</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;先序输入，#表示空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
int height(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return 0;
	&#125;
	else&#123;
		int hleft&#x3D;height(root-&gt;left);
		int hright&#x3D;height(root-&gt;right);
		return max(hleft+1,hright);
	&#125;

&#125;
int main()&#123;
	tree root;
	create(root);
	cout&lt;&lt;height(root)&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h4 id="根据满二叉树的先序求后序"><a href="#根据满二叉树的先序求后序" class="headerlink" title="根据满二叉树的先序求后序"></a>根据满二叉树的先序求后序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;满二叉树的后序序列
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; arr;

void post(arr data,int s,int en,arr&amp;a,int s1,int en1)&#123;
	int mid;&#x2F;&#x2F;左右子树分割
	if(s&lt;&#x3D;en)&#123;
		&#x2F;&#x2F;TODO
		&#x2F;&#x2F;满二叉树是对称图形，前序序列与后序序列不同的是，根位置发生了变化，其余不变
		a[en1]&#x3D;data[s];&#x2F;&#x2F;后序遍历的后面是前序遍历的前面
		mid&#x3D;(en-s)&#x2F;2;
		post(data,s+1,s+mid,a,s1,s1+mid-1);
		post(data,s+mid+1,en,a,s1+mid,en1-1);
	&#125;


&#125;
int main()&#123;
	arr data&#x3D;&#123;1,2,4,5,3,6,7&#125;;
	arr a(7);
	post(data,0,data.size(),a,0,6);
	for(int num:a)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;</code></pre>

<h4 id="根据先序和后序构建二叉树"><a href="#根据先序和后序构建二叉树" class="headerlink" title="根据先序和后序构建二叉树"></a>根据先序和后序构建二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;先序和中序，二叉树的重构
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
int pos&#x3D;0;&#x2F;&#x2F;全局变量，
void create(tree&amp;root,int pre[],int inorder[],int s,int end)&#123;
	if(s&lt;&#x3D;end)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;new treenode(pre[pos]);

		&#x2F;&#x2F;找到根节点在中序的下标，然后就可以分开递归
		int i;
		for(i&#x3D;s;i&lt;&#x3D;end;i++)&#123;
			&#x2F;&#x2F;TODO
			if(inorder[i]&#x3D;&#x3D;pre[pos])&#123;
				&#x2F;&#x2F;TODO
				break;
			&#125;
		&#125;
		pos++;&#x2F;&#x2F;准备下一个根节点
		create(root-&gt;left,pre,inorder,s,i-1);&#x2F;&#x2F;准备左子树
		create(root-&gt;right,pre,inorder,i+1,end);&#x2F;&#x2F;准备右子树
	&#125;
&#125;
void preorder(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;else&#123;
		cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
		preorder(root-&gt;left);
		preorder(root-&gt;right);
	&#125;

&#125;
void sinorder(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;else&#123;

		sinorder(root-&gt;left);
		cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;
		sinorder(root-&gt;right);
	&#125;
&#125;
int main()&#123;
	int pre[]&#x3D;&#123;1,2,4,5,3&#125;;
	int inorder[]&#x3D;&#123;4,2,5,1,3&#125;;
	tree root;
	create(root,pre,inorder,0,4);
	preorder(root);
	&#x2F;&#x2F;sinorder(root);
&#125;</code></pre>

<h4 id="中序线索化后找后序前驱"><a href="#中序线索化后找后序前驱" class="headerlink" title="中序线索化后找后序前驱"></a>中序线索化后找后序前驱</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;中序线索化，找后序前驱
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct treenode&#123;
	int data;
	int ltag;
	int rtag;
	struct treenode *left;
	struct treenode *right;
	treenode():data(-1),ltag(0),rtag(0),left(nullptr),right(nullptr)&#123;&#125;
	treenode(int x):data(x),ltag(0),rtag(0),left(nullptr),right(nullptr)&#123;&#125;
&#125;;
typedef struct treenode treenode;
typedef struct treenode* tree;
void create(tree&amp;root)&#123;
	cout&lt;&lt;&quot;先序输入，#为空&quot;&lt;&lt;endl;
	string str;
	cin&gt;&gt;str;
	if(str&#x3D;&#x3D;&quot;#&quot;)&#123;
		&#x2F;&#x2F;TODO
		root&#x3D;nullptr;
		return;
	&#125;
	int data&#x3D;stoi(str);
	root&#x3D;new treenode(data);
	create(root-&gt;left);
	create(root-&gt;right);
&#125;
&#x2F;&#x2F;中序线索化
treenode *pre&#x3D;nullptr;
void vithread(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	if(root-&gt;left&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		root-&gt;left&#x3D;pre;
		root-&gt;ltag&#x3D;1;
	&#125;
	if(pre!&#x3D;nullptr&amp;&amp;pre-&gt;right&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		pre-&gt;right&#x3D;root;
		pre-&gt;rtag&#x3D;1;
	&#125;
	pre&#x3D;root;
&#125;
void inorderth(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	inorderth(root-&gt;left);
	vithread(root);
	inorderth(root-&gt;right);
&#125;
void start_inorder(tree&amp;root)&#123;
	if(root&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		return;
	&#125;
	inorderth(root);
	if(pre-&gt;right&#x3D;&#x3D;nullptr)&#123;
		&#x2F;&#x2F;TODO
		pre-&gt;rtag&#x3D;1;
	&#125;
&#125;
tree trfind(tree&amp;p)&#123;
	&#x2F;&#x2F;线索化后的树，0代表孩子，1代表前驱
	treenode *res;
	if(p-&gt;rtag&#x3D;&#x3D;0)&#123;
		&#x2F;&#x2F;TODO
		res&#x3D;p-&gt;right;
	&#125;
	else if(p-&gt;ltag&#x3D;&#x3D;0)&#123;res&#x3D;p-&gt;left;&#125;
	else if(p-&gt;left&#x3D;&#x3D;nullptr)&#123;res&#x3D;nullptr;&#125;&#x2F;&#x2F;整个树最左边结点
	else&#123;
		&#x2F;&#x2F;当左右孩子均为空时
		&#x2F;&#x2F;后序前驱，是中序线索树中该结点前驱的左孩子
		while(p-&gt;ltag&#x3D;&#x3D;1&amp;&amp;p-&gt;left!&#x3D;nullptr)&#123;
			&#x2F;&#x2F;TODO
			p&#x3D;p-&gt;left;&#x2F;&#x2F;不断往上查找，p-&gt;left&#x3D;&#x3D;nullptr,也是在考虑最左结点
		&#125;
		if(p-&gt;ltag&#x3D;&#x3D;0)&#123;res&#x3D;p-&gt;left;&#125;
		else&#123;res&#x3D;nullptr;&#125;&#x2F;&#x2F;最左边结点
	&#125;
	return res;
&#125;
int main()&#123;
	tree root;
	create(root);
	tree t&#x3D;root;
	start_inorder(t);
	tree res&#x3D;trfind(root-&gt;right);
	cout&lt;&lt;res-&gt;data&lt;&lt;endl;
	return 0;
&#125;</code></pre>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="二分查找递归"><a href="#二分查找递归" class="headerlink" title="二分查找递归"></a>二分查找递归</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二分查找的递归写法
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
int b_search(vector&lt;int&gt; test,int l,int r,int x)&#123;
	if(l&gt;r)&#123;
		&#x2F;&#x2F;TODO
		return -1;
	&#125;
	int mid&#x3D;(l+r)&#x2F;2;
	if(x&gt;test[mid])&#123;
		&#x2F;&#x2F;TODO
		return b_search(test,mid+1,r,x);
	&#125;
	else if(x&lt;test[mid])&#123;
		&#x2F;&#x2F;TODO
		return b_search(test,l,mid-1,x);
	&#125;
	else&#123;
		return mid;
	&#125;
&#125;
int main()&#123;
	vector&lt;int&gt; test;
	for(int i&#x3D;0;i&lt;&#x3D;10;i++)&#123;
		&#x2F;&#x2F;TODO
		test.push_back(i);
	&#125;
	cout&lt;&lt;b_search(test,1,test.size(),5);
	return 0;
&#125;</code></pre>

<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="bfs最短路径"><a href="#bfs最短路径" class="headerlink" title="bfs最短路径"></a>bfs最短路径</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;bfs单源最短路径
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxv 4
#define maxsize 100
&#x2F;&#x2F;定义图的结构体
struct graph&#123;
	int vnum;
	char name[4];
	int a[4][4];
	graph():vnum(4),name&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;,a&#123;
	&#123;0,1,9999,9999&#125;,
	&#123;1,0,1,1&#125;,
	&#123;9999,1,0,9999&#125;,
	&#123;9999,1,9999,0&#125;&#125;&#123;&#125;
&#125;;
vector&lt;bool&gt; visited(4);
typedef struct graph graph;
struct myque&#123;
	int v[100];
	int f,r,tag;
	myque():f(0),r(0),tag(0)&#123;&#125;
&#125;;
typedef struct myque myque;
int qsize(myque q)&#123;return (maxsize-(q.f-q.r))%maxsize;&#125;
bool qfull(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;1;&#125;
bool qnone(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;0;&#125;
bool pushque(myque &amp;q,int &amp;i)&#123;
	if(qfull(q))&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;队列已满&quot;&lt;&lt;endl;
		return false;
	&#125;
	q.v[q.r]&#x3D;i;
	q.r&#x3D;(q.r+1)%maxsize;
	return true;
&#125;
bool popque(myque &amp;q,int&amp;i)&#123;
	if(qnone(q))&#123;
		cout&lt;&lt;&quot;队列已空&quot;&lt;&lt;endl;
		return false;
	&#125;
	i&#x3D;q.v[q.f];
	q.f&#x3D;(q.f+1)%maxsize;
	return true;
&#125;
int path[4];
int prevex[4];
void bfs(graph g,int num)&#123;
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		path[i]&#x3D;9999;
		prevex[i]&#x3D;-1;
	&#125;
	myque q;
	prevex[num]&#x3D;num;
	path[num]&#x3D;0;
	visited[num]&#x3D;true;
	pushque(q,num);
	while(qsize(q)&gt;0)&#123;
		&#x2F;&#x2F;TODO
		popque(q,num);
		for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
			&#x2F;&#x2F;TODO
			if(visited[i]&#x3D;&#x3D;0&amp;&amp;g.a[num][i]!&#x3D;9999)&#123;
				&#x2F;&#x2F;TODO
				path[i]&#x3D;path[num]+1;
				prevex[i]&#x3D;num;
				visited[i]&#x3D;true;
				pushque(q,i);
			&#125;
		&#125;
	&#125;
&#125;
int main()&#123;
	graph g;
	bfs(g,0);
	for(int i&#x3D;0;i&lt;4;i++)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;
	&#125;
	return 0;
&#125;
</code></pre>

<h4 id="dfs逆拓扑"><a href="#dfs逆拓扑" class="headerlink" title="dfs逆拓扑"></a>dfs逆拓扑</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;dfs实现逆拓扑序列和拓扑序列AOV
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct graph&#123;
	int vnum;
	int edge[5][5];
	graph():vnum(5),edge&#123;
	&#123;0,1,9999,9999,9999&#125;,
	&#123;9999,0,9999,1,9999&#125;,
	&#123;9999,9999,0,1,1&#125;,
	&#123;9999,9999,9999,0,1&#125;,
	&#123;9999,9999,9999,9999,0&#125;&#125;&#123;&#125;
&#125;;
typedef struct graph graph;
bool visited[5];
void dfs(graph g,int m)&#123;
	visited[m]&#x3D;true;
	for(int i&#x3D;0;i&lt;5;i++)&#123;
		&#x2F;&#x2F;TODO
		if(visited[i]&#x3D;&#x3D;0&amp;&amp;g.edge[m][i]!&#x3D;9999&amp;&amp;g.edge[m][i]!&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			dfs(g,i);
		&#125;
	&#125;
	cout&lt;&lt;m&lt;&lt;&quot; &quot;;
&#125;
void dfsall(graph g)&#123;
	for(int i&#x3D;0;i&lt;5;i++)&#123;
		&#x2F;&#x2F;TODO
		visited[i]&#x3D;false;
	&#125;
	for(int i&#x3D;0;i&lt;5;i++)&#123;
		&#x2F;&#x2F;TODO
		if(visited[i]&#x3D;&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			dfs(g,i);
		&#125;
	&#125;
&#125;
int main()&#123;
	graph g;
	dfsall(g);
	
	return 0;
&#125;</code></pre>

<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;最小生成树prim&amp;&amp;kruskal
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxv 6
struct graph&#123;
	int vnum;
	char name[6];
	int edge[maxv][maxv];
	graph():vnum(6),name&#123;&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;&#125;,edge&#123;
	&#123;0,6,5,1,9999,9999&#125;,
	&#123;6,0,9999,5,3,9999&#125;,
	&#123;5,9999,0,4,9999,2&#125;,
	&#123;1,5,4,0,6,4&#125;,
	&#123;9999,3,9999,6,0,6&#125;,
	&#123;9999,9999,2,4,6,0&#125;&#125;&#123;&#125;
&#125;;
typedef struct graph graph;
void prim(graph g)&#123;
	int lowcost[6];&#x2F;&#x2F;存储到达6个点的花费代价
	int adjvex[6];&#x2F;&#x2F;存储最后6条边的起点
	&#x2F;&#x2F;把第一条边加入

	for(int i&#x3D;1;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		lowcost[i]&#x3D;g.edge[0][i];
		adjvex[i]&#x3D;0;&#x2F;&#x2F;起初起点都是0，避免找不到顶点
	&#125;
	&#x2F;&#x2F;开始一行行查找最小的代价，并把它加入

	for(int i&#x3D;1;i&lt;g.vnum;i++)&#123;
		int minedge&#x3D;9999,minvex;
		int k&#x3D;1;
		while(k&lt;g.vnum)&#123;
			&#x2F;&#x2F;TODO
			if((lowcost[k]!&#x3D;0)&amp;&amp;lowcost[k]&lt;minedge)&#123;
				&#x2F;&#x2F;TODO
				minedge&#x3D;lowcost[k];
				minvex&#x3D;k;
			&#125;
			k++;
		&#125;

		&#x2F;&#x2F;找到此时能到达花费代价最小的边
		&#x2F;&#x2F;更新图中信息
		lowcost[minvex]&#x3D;0;
		&#x2F;&#x2F;每确定一个点就将和他相连的边打印出来
		cout&lt;&lt;&quot;(&quot;&lt;&lt;g.name[adjvex[minvex]]&lt;&lt;&quot;,&quot;&lt;&lt;g.name[minvex]&lt;&lt;&quot;)&quot;&lt;&lt;&quot; &quot;;
		&#x2F;&#x2F;更新图
		for(int j&#x3D;1;j&lt;g.vnum;j++)&#123;
			&#x2F;&#x2F;TODO
			if((lowcost[j]!&#x3D;0)&amp;&amp;g.edge[minvex][j]&lt;lowcost[j])&#123;
				&#x2F;&#x2F;TODO
				lowcost[j]&#x3D;g.edge[minvex][j];
				adjvex[j]&#x3D;minvex;
			&#125;
		&#125;

	&#125;
&#125;
int main()&#123;
	graph g;
	prim(g);
	return 0;
&#125;
&#x2F;*int Find(int *parent, int f) &#123;
while (parent[f] &gt; 0) &#123;
f &#x3D; parent[f];&#x2F;&#x2F;如果f点有其他的终点，将其返回
&#125;
return f;
&#125;


void MiniSpanTree_Kruskal(MGraph G) &#123;
int i, j, n, m, k;
Edge edges[G.numEdges];
int parent[G.numVertexes];

&#x2F;&#x2F;******************adjacency Matrix to Edges Array********************
k &#x3D; 0;
for (i &#x3D; 0; i &lt; G.numVertexes; i++) &#123;
for (j &#x3D; (i + 1); j &lt; G.numVertexes; j++) &#123; &#x2F;*undigraph just deal with upper triangle Matrix*&#x2F;
&#x2F;*if (G.arc[i][j] !&#x3D; INFINITY) &#123;
edges[k].weight &#x3D; G.arc[i][j];
edges[k].begin &#x3D; i;
edges[k].end &#x3D; j;
k++;
&#125;
&#125;
&#125;
&#x2F;&#x2F;******************adjacency Matrix to Edges Array********************
&#x2F;&#x2F;print the edge array.
&#x2F;&#x2F;for(i&#x3D;0;i&lt;G.numEdges;i++)
&#x2F;&#x2F;	&#123;
&#x2F;&#x2F;		printf(&quot;edge[%d]: begin: %d, end: %d, weight: %d \n&quot;,i,edges[i].begin,edges[i].end,edges[i].weight);
&#x2F;&#x2F;	&#125;

&#x2F;&#x2F;************sort the edges array with bubble sorting method**********
Edge temp;
for (k &#x3D; 1; k &lt;&#x3D; G.numEdges - 1; k++) &#123;
for (i &#x3D; 0; i &lt; G.numEdges - k; i++) &#123;
if (edges[i].weight &gt; edges[i + 1].weight) &#123;
temp &#x3D; edges[i];
edges[i] &#x3D; edges[i + 1];
edges[i + 1] &#x3D; temp;
&#125;

&#125;
&#125;&#x2F;&#x2F;将边排序

&#x2F;&#x2F;print the ordered edge array
&#x2F;&#x2F;for(i&#x3D;0;i&lt;G.numEdges;i++)
&#x2F;&#x2F;	&#123;
&#x2F;&#x2F;		printf(&quot;edge[%d]: begin: %d, end: %d, weight: %d \n&quot;,i,edges[i].begin,edges[i].end,edges[i].weight);
&#x2F;&#x2F;	&#125;
&#x2F;&#x2F;************sort the edges array with bubble sorting method**********

for (i &#x3D; 0; i &lt; G.numVertexes; i++) &#123;
parent[i] &#x3D; 0;
&#125;
printf(&quot;The minimum spanning tree is (Kruskal):\n&quot;);
for (i &#x3D; 0; i &lt; G.numEdges; i++) &#123;
n &#x3D; Find(parent, edges[i].begin);
m &#x3D; Find(parent, edges[i].end);
if (n !&#x3D; m) &#123;
parent[n] &#x3D; m;
printf(&quot;[(%c,%c) %d] &quot;, G.vexs[edges[i].begin], G.vexs[edges[i].end], edges[i].weight);
&#125;
&#125;
printf(&quot;\n&quot;);
&#125;

 *&#x2F;</code></pre>

<h4 id="迪杰斯特拉单源最短路"><a href="#迪杰斯特拉单源最短路" class="headerlink" title="迪杰斯特拉单源最短路"></a>迪杰斯特拉单源最短路</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;dijkstra算法

#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct graph&#123;
	int vnum;
	string name[5];
	int edge[5][5];
	graph():vnum(5),name&#123;&quot;v0&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;&#125;,edge&#123;
	&#123;0,10,9999,7,5&#125;,
	&#123;10,0,6,9999,2&#125;,
	&#123;9999,6,0,6,9&#125;,
	&#123;7,9999,6,0,2&#125;,
	&#123;5,2,9,2,0&#125;&#125;&#123;&#125;
&#125;;
typedef struct graph graph;
int finded[5];
int path[5];
int prevex[5];
void dijkstra(graph g,int m)&#123;
	&#x2F;&#x2F;初始化
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		finded[i]&#x3D;0;
		path[i]&#x3D;g.edge[m][i];;
		prevex[i]&#x3D;-1;
	&#125;
	prevex[m]&#x3D;m;
	finded[m]&#x3D;1;
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		int minedge&#x3D;9999,minvex,j&#x3D;0;
		while(j&lt;g.vnum)&#123;
			&#x2F;&#x2F;TODO
			if(finded[j]&#x3D;&#x3D;0&amp;&amp;path[j]&lt;minedge)&#123;
				&#x2F;&#x2F;TODO
				minedge&#x3D;path[j];
				minvex&#x3D;j;
			&#125;
			j++;
		&#125;
		&#x2F;&#x2F;找到一行中最少的路径
		&#x2F;&#x2F;更新path,prevex,finded;
		finded[minvex]&#x3D;1;
		for(int k&#x3D;0;k&lt;g.vnum;k++)&#123;
			&#x2F;&#x2F;TODO
			if(finded[k]&#x3D;&#x3D;0&amp;&amp;path[minvex]+g.edge[minvex][k]&lt;path[k])&#123;
				&#x2F;&#x2F;TODO
				path[k]&#x3D;path[minvex]+g.edge[minvex][k];
				prevex[k]&#x3D;minvex;
			&#125;
		&#125;


	&#125;
&#125;
int main()&#123;
	graph g;
	dijkstra(g,0);
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;
	&#125;
	return 0;
&#125;</code></pre>

<h4 id="dfs-amp-amp-bfs"><a href="#dfs-amp-amp-bfs" class="headerlink" title="dfs&amp;&amp;bfs"></a>dfs&amp;&amp;bfs</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;图的深度优先遍历
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define maxv 4
#define maxsize 100
&#x2F;&#x2F;定义图的结构体
struct graph&#123;
	int vnum;
	char name[4];
	int a[4][4];
	graph():vnum(4),name&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;,a&#123;
	&#123;0,1,9999,9999&#125;,
	&#123;1,0,1,1&#125;,
	&#123;9999,1,0,9999&#125;,
	&#123;9999,1,9999,0&#125;&#125;&#123;&#125;
&#125;;
vector&lt;bool&gt; visited(4);
typedef struct graph graph;
struct myque&#123;
	int v[100];
	int f,r,tag;
	myque():f(0),r(0),tag(0)&#123;&#125;
&#125;;
typedef struct myque myque;
int qsize(myque q)&#123;return (maxsize-(q.f-q.r))%maxsize;&#125;
bool qfull(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;1;&#125;
bool qnone(myque q)&#123;return q.f&#x3D;&#x3D;q.r&amp;&amp;q.tag&#x3D;&#x3D;0;&#125;
bool pushque(myque &amp;q,int &amp;i)&#123;
	if(qfull(q))&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;&quot;队列已满&quot;&lt;&lt;endl;
		return false;
	&#125;
	q.v[q.r]&#x3D;i;
	q.r&#x3D;(q.r+1)%maxsize;
	return true;
&#125;
bool popque(myque &amp;q,int&amp;i)&#123;
	if(qnone(q))&#123;
		cout&lt;&lt;&quot;队列已空&quot;&lt;&lt;endl;
		return false;
	&#125;
	i&#x3D;q.v[q.f];
	q.f&#x3D;(q.f+1)%maxsize;
	return true;
&#125;
void dfs(graph g,int i)&#123;
	int j&#x3D;0;
	visited[i]&#x3D;1;&#x2F;&#x2F;标志i结点已经访问过
	cout&lt;&lt;g.name[i]&lt;&lt;&quot; &quot;;
	for(j&#x3D;0;j&lt;g.vnum;j++)&#123;
		&#x2F;&#x2F;TODO
		if(g.a[i][j]!&#x3D;9999&amp;&amp;visited[j]&#x3D;&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			dfs(g,j);
		&#125;
	&#125;

&#125;
void dfsall(graph g)&#123;
	&#x2F;&#x2F;初始化，是否访问过标志数组
	for(int i&#x3D;0;i&lt;visited.size();i++)&#123;
		&#x2F;&#x2F;TODO
		visited[i]&#x3D;0;
	&#125;
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		if(!visited[i])&#123;
			&#x2F;&#x2F;TODO
			dfs(g,i);
		&#125;
	&#125;
&#125;
void bfs(graph g,int i)&#123;
	myque q;
	visited[i]&#x3D;1;
	cout&lt;&lt;g.name[i]&lt;&lt;&quot; &quot;;
	pushque(q,i);
	int j;
	while(qsize(q)&gt;0)&#123;
		&#x2F;&#x2F;TODO
		popque(q,i);

		for(j&#x3D;0;j&lt;g.vnum;j++)&#123;
			&#x2F;&#x2F;TODO
			if(g.a[i][j]!&#x3D;9999&amp;&amp;visited[j]&#x3D;&#x3D;0)&#123;
				visited[j]&#x3D;1;
				cout&lt;&lt;g.name[j]&lt;&lt;&quot; &quot;;
				pushque(q,j);
			&#125;
		&#125;
	&#125;
&#125;
void bfsall(graph g)&#123;
	&#x2F;&#x2F;初始化
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		visited[i]&#x3D;0;
	&#125;
	for(int i&#x3D;0;i&lt;g.vnum;i++)&#123;
		&#x2F;&#x2F;TODO
		if(!visited[i])&#123;

			bfs(g,i);&#x2F;&#x2F;TODO
		&#125;
	&#125;
&#125;
int v&#x3D;0,edge&#x3D;0;
void dfstest(graph g,int i)&#123;
	int j&#x3D;0;
	visited[i]&#x3D;1;&#x2F;&#x2F;标志i结点已经访问过
	cout&lt;&lt;g.name[i]&lt;&lt;&quot; &quot;;
	v++;
	for(j&#x3D;0;j&lt;g.vnum;j++)&#123;
		&#x2F;&#x2F;TODO
		if(g.a[i][j]!&#x3D;9999&amp;&amp;g.a[i][j]!&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			edge++;
			if(visited[j]&#x3D;&#x3D;0)&#123;
				&#x2F;&#x2F;TODO
				dfstest(g,j);
			&#125;

		&#125;
	&#125;
&#125;
&#x2F;&#x2F;判断图是否是树
bool istree(graph g)&#123;
	for(int i&#x3D;0;i&lt;visited.size();i++)&#123;
		&#x2F;&#x2F;TODO
		visited[i]&#x3D;0;
	&#125;
	dfstest(g,0);
	cout&lt;&lt;v&lt;&lt;endl;
	cout&lt;&lt;edge&lt;&lt;endl;
	if(v&#x3D;&#x3D;g.vnum&amp;&amp;edge&#x3D;&#x3D;2*(g.vnum-1))&#123;
		&#x2F;&#x2F;TODO
		return true;
	&#125;else&#123;return false;&#125;
&#125;
int main()&#123;
	graph g;
	cout&lt;&lt;g.a[2][2]&lt;&lt;endl;
	cout&lt;&lt;g.name[0]&lt;&lt;endl;
	&#x2F;&#x2F;dfsall(g);
	cout&lt;&lt;endl;
	&#x2F;&#x2F;bfsall(g);
	cout&lt;&lt;istree(g);
	return 0;
&#125;
</code></pre>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;插入排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void insertsort(myarray test)&#123;
	int j&#x3D;1;
	while(j&lt;test.size())&#123;
		&#x2F;&#x2F;TODO
		if(test[j-1]&gt;test[j])&#123;
			&#x2F;&#x2F;TODO
			int temp&#x3D;test[j];&#x2F;&#x2F;小的前移
			int i&#x3D;j-1;
			while(test[i]&gt;temp&amp;&amp;i&gt;&#x3D;0)&#123;
				&#x2F;&#x2F;TODO
				test[i+1]&#x3D;test[i];
				i--;
			&#125;
			test[i+1]&#x3D;temp;
		&#125;
		j++;
	&#125;
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	insertsort(test);
	return 0;
&#125;

</code></pre>

<h4 id="二分查找-amp-amp-插入排序"><a href="#二分查找-amp-amp-插入排序" class="headerlink" title="二分查找&amp;&amp;插入排序"></a>二分查找&amp;&amp;插入排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;优化插入排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void half_insert_sort(myarray test)&#123;
	int j&#x3D;1;
	while(j&lt;test.size())&#123;
		&#x2F;&#x2F;TODO
		if(test[j-1]&gt;test[j])&#123;
			&#x2F;&#x2F;TODO
			int temp&#x3D;test[j];
			int l&#x3D;0,r&#x3D;j-1;
			while(l&lt;&#x3D;r)&#123;
				&#x2F;&#x2F;TODO
				int mid&#x3D;(l+r)&#x2F;2;
				if(test[mid]&gt;temp)&#123;
					&#x2F;&#x2F;TODO
					r&#x3D;mid-1;
				&#125;else&#123;
					&#x2F;&#x2F;mid 等于temp时，为保证稳定，所以l继续右移，是temp放在相等的值后面
					l&#x3D;mid+1;
				&#125;

			&#125;
			&#x2F;&#x2F;h指向插入位置的前一位
			&#x2F;&#x2F;开始移动并插入
			int i&#x3D;j-1;
			while(i&gt;r&amp;&amp;i&gt;&#x3D;0)&#123;
				&#x2F;&#x2F;TODO
				test[i+1]&#x3D;test[i];
				i--;
			&#125;
			test[r+1]&#x3D;temp;
		&#125;
		j++;
	&#125;
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	half_insert_sort(test);
	return 0;
&#125;</code></pre>



<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;希尔排序
&#x2F;&#x2F;将数组分成若干个子表，进行插入排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void shellsort(myarray test)&#123;
	int d&#x3D;test.size()&#x2F;2;
	while(d&gt;&#x3D;1)&#123;
		&#x2F;&#x2F;TODO
		int i&#x3D;d;
		while(i&lt;test.size())&#123;
			&#x2F;&#x2F;TODO
			if(test[i-d]&gt;test[i])&#123;
				&#x2F;&#x2F;TODO
				int temp&#x3D;test[i];
				int j&#x3D;i-d;
				while(j&gt;&#x3D;0&amp;&amp;test[j]&gt;temp)&#123;
					&#x2F;&#x2F;TODO
					test[j+d]&#x3D;test[j];
					j&#x3D;j-d;
				&#125;
				test[j+d]&#x3D;temp;

			&#125;
			i++;
		&#125;
		d&#x3D;d&#x2F;2;
	&#125;

	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	shellsort(test);
	return 0;
</code></pre>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;堆排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void adjust(myarray&amp;test,int root,int len)&#123;
	int l&#x3D;2*root;
	int r&#x3D;2*root+1;
	int maxwhere&#x3D;root;
	if(l&lt;len&amp;&amp;test[maxwhere]&lt;test[l])&#123;
		&#x2F;&#x2F;TODO
		maxwhere&#x3D;l;
	&#125;
	if(r&lt;len&amp;&amp;test[maxwhere]&lt;test[r])&#123;
		&#x2F;&#x2F;TODO
		maxwhere&#x3D;r;
	&#125;
	&#x2F;&#x2F;连续两个if找出三个数值最大的下标
	if(maxwhere!&#x3D;root)&#123;
		&#x2F;&#x2F;TODO
		swap(test[root],test[maxwhere]);&#x2F;&#x2F;交互，但是下标没有变化
		&#x2F;&#x2F;交换后，max指向的就不是最大值了，而是背换下来的值，会对下一层产生影响，所以向下一层递归
		adjust(test,maxwhere,len);
	&#125;
&#125;
void heapsort(myarray&amp;test)&#123;
	int maxwhere&#x3D;(int)(9&#x2F;2);
	for(int i&#x3D;maxwhere;i&gt;&#x3D;0;i--)&#123;
		&#x2F;&#x2F;TODO
		adjust(test,i,8);
	&#125;&#x2F;&#x2F;建堆就是第一次调整，for循环表示从下往上调整，调整函数里由上往下


	&#x2F;&#x2F;开始排序
	for(int i&#x3D;8;i&gt;&#x3D;0;i--)&#123;
		&#x2F;&#x2F;TODO
		cout&lt;&lt;test[0]&lt;&lt;&quot; &quot;;
		swap(test[0],test[i]);
		adjust(test,0,i-1);
	&#125;

&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	heapsort(test);
	return 0;
&#125;</code></pre>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;简单选择排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void simple_select_sort(myarray test)&#123;
	int i&#x3D;0;
	while(i&lt;test.size())&#123;
		&#x2F;&#x2F;TODO
		int minnum&#x3D;test[i];
		int j&#x3D;i+1;
		while(j&lt;test.size())&#123;
			&#x2F;&#x2F;TODO
			if(minnum&gt;test[j])&#123;
				&#x2F;&#x2F;TODO
				int temp&#x3D;minnum;
				minnum&#x3D;test[j];
				&#x2F;&#x2F;这里test[j]必须赋值，把未排序的数储存
				test[j]&#x3D;temp;
			&#125;
			j++;
		&#125;
		test[i]&#x3D;minnum;
		i++;
	&#125;
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	simple_select_sort(test);
	return 0;
&#125;</code></pre>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;归并排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;

myarray test&#123;1,2,3,4,5,6,7,2&#125;;
myarray help(test.size(),0);
void mysort(myarray&amp;test,int l,int r,int divd)&#123;
	int k&#x3D;0;
	while(k&lt;test.size())&#123;
		&#x2F;&#x2F;TODO
		help[k]&#x3D;test[k];
		k++;
	&#125;
	int i&#x3D;0,j&#x3D;divd+1;
	k&#x3D;0;
	for(;i&lt;&#x3D;divd&amp;&amp;j&lt;&#x3D;r;k++)&#123;
		&#x2F;&#x2F;TODO
		if(help[i]&lt;&#x3D;help[j])&#123;
			&#x2F;&#x2F;TODO
			test[k]&#x3D;help[i];
			i++;
		&#125;else&#123;
			test[k]&#x3D;help[j];
			j++;
		&#125;

	&#125;

	&#x2F;&#x2F;是否有剩余
	while(i&lt;&#x3D;divd)&#123;
		&#x2F;&#x2F;TODO
		test[k]&#x3D;help[i];
		i++;
		k++;
	&#125;
	while(j&lt;&#x3D;r)&#123;
		&#x2F;&#x2F;TODO
		test[k]&#x3D;help[j];
		j++;
		k++;
	&#125;

&#125;
void mydivid(myarray&amp;test,int l,int r)&#123;
	if(l&lt;r)&#123;
		&#x2F;&#x2F;TODO
		int mid&#x3D;(l+r)&#x2F;2;

		&#x2F;&#x2F;先分
		mydivid(test,l,mid);
		mydivid(test,mid+1,r);


		&#x2F;&#x2F;再排,合并时必须知道从那间隔
		mysort(test,l,r,mid);
	&#125;
&#125;
int main()&#123;
	mydivid(test,0,test.size()-1);
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return 0;
&#125;</code></pre>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;快速排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
int findpos(myarray&amp;test,int l,int r)&#123;
	int temp&#x3D;test[l];
	while(l&lt;r)&#123;
		while(l&lt;r&amp;&amp;test[r]&gt;&#x3D;temp)&#123;
			r--;
		&#125;
		test[l]&#x3D;test[r];
		while(l&lt;r&amp;&amp;test[l]&lt;&#x3D;temp)&#123;
			&#x2F;&#x2F;TODO
			l++;
		&#125;
		test[r]&#x3D;test[l];
	&#125;
	test[l]&#x3D;temp;
	&#x2F;&#x2F;for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	&#x2F;&#x2F;cout&lt;&lt;endl;
	return l;

&#125;
void fastsort(myarray&amp;test,int l,int r)&#123;
	if(l&lt;r)&#123;
		int pos&#x3D;findpos(test,l,r);
		fastsort(test,l,pos-1);
		fastsort(test,pos+1,r);

	&#125;

&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	fastsort(test,0,test.size()-1);
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
	return 0;
&#125;</code></pre>

<h4 id="奇数前偶数后"><a href="#奇数前偶数后" class="headerlink" title="奇数前偶数后"></a>奇数前偶数后</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;奇数前，偶数后
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void fastsort_2(myarray test)&#123;
	int l&#x3D;0,r&#x3D;test.size()-1;
	&#x2F;&#x2F;左边找偶数
	&#x2F;&#x2F;右边找奇数，然后交换
	while(l&lt;r)&#123;
		&#x2F;&#x2F;TODO
		while(l&lt;r&amp;&amp;test[l]%2!&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			l++;
		&#125;
		while(l&lt;r&amp;&amp;test[r]%2&#x3D;&#x3D;0)&#123;
			&#x2F;&#x2F;TODO
			r--;
		&#125;
		if(l&lt;r)&#123;
			&#x2F;&#x2F;TODO
			swap(test[l],test[r]);
			l++;
			r--;
		&#125;
	&#125;
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	fastsort_2(test);
&#125;</code></pre>



<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;冒泡排序
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void bubble_sort(myarray &amp;test)&#123;
	int i&#x3D;0;
	while(i&lt;test.size())&#123;
		&#x2F;&#x2F;TODO
		bool flag&#x3D;false;
		int j&#x3D;test.size()-1;
		while(j&gt;i)&#123;
			&#x2F;&#x2F;TODO
			if(test[j-1]&gt;test[j])&#123;
				&#x2F;&#x2F;TODO
				int temp&#x3D;test[j-1];
				test[j-1]&#x3D;test[j];
				test[j]&#x3D;temp;
				flag&#x3D;true;
			&#125;

			j--;
		&#125;
		if(flag&#x3D;&#x3D;false)&#123;
			&#x2F;&#x2F;TODO
			for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
			return;
		&#125;
		i++;
	&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	bubble_sort(test);
	return 0;
&#125;</code></pre>

<h4 id="双冒泡排序"><a href="#双冒泡排序" class="headerlink" title="双冒泡排序"></a>双冒泡排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;双冒泡排序,每次遍历一趟，确定一个最大值和最小值
&#x2F;&#x2F;low左边是确定的最小值，high右边是确定的最大值
#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef vector&lt;int&gt; myarray;
void duble_bubble_sort(myarray test)&#123;
	int l&#x3D;0, r&#x3D;test.size()-1;
	bool flag&#x3D;true;
	while(l&lt;r&amp;&amp;flag)&#123;
		&#x2F;&#x2F;TODO
		flag&#x3D;false;&#x2F;&#x2F;表示一开始没有发生变化
		for(int i&#x3D;l;i&lt;r;i++)&#123;
			&#x2F;&#x2F;TODO
			if(test[i]&gt;test[i+1])&#123;
				&#x2F;&#x2F;TODO
				int temp&#x3D;test[i];
				test[i]&#x3D;test[i+1];
				test[i+1]&#x3D;temp;
				flag &#x3D;true;
			&#125;
		&#125;
		r--;
		&#x2F;&#x2F;最大值确定一个，从左到右



		for(int i&#x3D;r;i&gt;l;i--)&#123;
			&#x2F;&#x2F;TODO
			if(test[i-1]&gt;test[i])&#123;
				&#x2F;&#x2F;TODO
				int temp&#x3D;test[i-1];
				test[i-1]&#x3D;test[i];
				test[i]&#x3D;temp;
				flag&#x3D;true;
			&#125;
		&#125;
		l++;
		&#x2F;&#x2F;最小值确定一个
	&#125;
	for(auto num:test)&#123;cout&lt;&lt;num&lt;&lt;&quot; &quot;;&#125;
&#125;
int main()&#123;
	myarray test&#123;4,532,44,2323,44350,1,4,24,333&#125;;
	duble_bubble_sort(test);
	return 0;
&#125;</code></pre>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>dhcp协议名为动态主机配置协议，主要是为新加入计算机网络中的计算机自动配置ip地址，这样一台主机就可以即插即用，不需要人工配置ip地址。</p>
<h2 id="TCP-x2F-UDP区别"><a href="#TCP-x2F-UDP区别" class="headerlink" title="TCP&#x2F;UDP区别"></a>TCP&#x2F;UDP区别</h2><p>TCP和UDP都是传输层中的协议。</p>
<p>TCP面向连接提供可靠的数据传输服务，UDP面向非连接不提供可靠的数据传输服务。</p>
<p>TCP面向字节流数据，传输慢。UDP面向报文数据，传输快。</p>
<h2 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h2><p>http是超文本传输协议，https是具有安全性的SSL加密传输协议。</p>
<p>http的端口是80，https的端口是443。</p>
<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>从功能上来讲，get一般从服务器上来获取资源，post一般用来更新服务器上的资源。</p>
<p>从安全性上来讲，post的安全性要比get的安全性高，因为get请求提交的数据将明文出现在URL上，而post请求参数则被包装到请求体中，相对更安全。</p>
<p>从请求大小来看，get请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，post请求是没有大小限制的。</p>
<h2 id="csma-x2F-cd"><a href="#csma-x2F-cd" class="headerlink" title="csma&#x2F;cd"></a>csma&#x2F;cd</h2><p>csma&#x2F;cd是载波监听多路访问&#x2F;冲突检测方法，其基本思想是：当一个节点要发送数据时，首先监听信道，如果信道空闲就发送数据，并继续监听；如果在数据发送过程中监听到了冲突，则立刻停止发送，等待一段随机的时间后，重新开始尝试发送数据。</p>
<h2 id="ipv4与ipv6"><a href="#ipv4与ipv6" class="headerlink" title="ipv4与ipv6"></a>ipv4与ipv6</h2><p>ipv6比ipv4更安全，而且存储空间更大，ipv4长度为32位(4个字节)，ipv6长度为128位(16个字节)。</p>
<h2 id="子网掩码与ip地址"><a href="#子网掩码与ip地址" class="headerlink" title="子网掩码与ip地址"></a>子网掩码与ip地址</h2><p>在互联网中有多台主机，为了区分主机，人们给每台主机分配了一个专门的地址作为标识，称为ip地址。<br>子网掩码的作用是用来区分网络上的主机是否在同一网络段内，子网掩码不能单独存在，必须结合ip地址一起使用，子网掩码只有一个作用，就是将某个ip地址划分为网络地址和主机地址</p>
<h2 id="同步通信和异步通信"><a href="#同步通信和异步通信" class="headerlink" title="同步通信和异步通信"></a>同步通信和异步通信</h2><p>同步通信是通信双方先建立同步，双方的时钟必须调整到一个频率，主要有两种同步方式。</p>
<p>一种是全网同步，用一个非常精确的主时钟对全网所有结点的时钟进行同步。</p>
<p>另一种是准同步，各结点的时钟之间允许有微小的误差，然后采用其他措施实现同步传输，同步通信数据率较高，但实现代价也较高。</p>
<p>异步通信在发送字符时，发送字符之间的时间间隔时任意的，接收端时刻做好接收的准备，发送端可以在任意时刻开始发送字符，因此必须在每个字符开始和结束的地方加上标志，开始位与停止位。</p>
<p>异步通信也可以用帧作为发送的单位。异步通信的通信设备简单，便宜，但传输效率低</p>
<h2 id="数据链路层组装成帧的方法"><a href="#数据链路层组装成帧的方法" class="headerlink" title="数据链路层组装成帧的方法"></a>数据链路层组装成帧的方法</h2><p>字符计数法。在帧头部使用一个计数字段来表明帧内字符数。</p>
<p>首尾定界法。使用特定字符表示帧的开始和结束。</p>
<p>违规编码法。信号传输过程中采用违规的编码来表示帧的开始和终止。</p>
<h2 id="滑动窗口流量控制"><a href="#滑动窗口流量控制" class="headerlink" title="滑动窗口流量控制"></a>滑动窗口流量控制</h2><p>在任意时刻，发送方都维持一组连续的发送帧的序号，称为发送窗口，同时接收方也维持一组连续的接受帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，而发送窗口的大小代表在还未收到对方确认信息的情况下，发送方最多还可以发送多少个数据帧。在接收方，只有收的数据帧的序号落入接收窗口内，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律丢弃。</p>
<h2 id="后退N帧协议流量控制"><a href="#后退N帧协议流量控制" class="headerlink" title="后退N帧协议流量控制"></a>后退N帧协议流量控制</h2><p>在后退N帧式ARQ中，发送方无须在收到上一个帧的ACK后才能开始发送下一帧，而是可以连续发送帧，当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收信息帧之后的所有未被确认的帧，或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方不得不重传该出错帧及最后的N个帧，接收方只按顺序接收帧。</p>
<h2 id="选择重传协议流量控制"><a href="#选择重传协议流量控制" class="headerlink" title="选择重传协议流量控制"></a>选择重传协议流量控制</h2><p>为了进一步提高信道利用率，可设法只重传出现差错的数据帧或计时器超时的数据帧，但此时必须加大接收窗口，以便收下发送序号不连读但仍处在接收窗口中的那些数据帧，等到所缺序号的数据帧收到后，再一并送交主机。</p>
<p>在选择重传协议中，每个发送缓冲区对应一个计时器，当计时器超时后，缓冲区的帧就会重传，另外该协议使用了比上述其他协议更有效的差错处理策略，即一旦接收方怀疑帧出错，就会发送一个否定帧NAK给发送方，要求发送方对NAK中的指定帧进行重传。</p>
<h2 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h2><p>数据链路层的可靠传输机制是考确认和超时重传两种机制完成。</p>
<p>确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。</p>
<p>超时重传是指发送方在发送某个数据帧后就开启一个计时器，在一定时间内如果没有得到传送的数据帧的确认帧那么就重新发送该数据帧，知道发送成功为止。</p>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>csma(载波监听多路访问)<br>非持续式： 如果介质空闲，开始发送。如果介质忙，则等待一个随机分布的时间，然后重复之前的步骤<br>1-持续式：如果介质空闲，开始发送。如果介质忙，就一直监听，直到空闲立即发送。<br>p-持续式：经侦听，如果介质空闲，则以p的概率发送，以(1-p)的概率的延迟一个时间单元再发送。</p>
<h2 id="ppp协议"><a href="#ppp协议" class="headerlink" title="ppp协议"></a>ppp协议</h2><p>ppp协议也叫点到点协议，是为在同等单元之间传输数据包建立的的简单链路设计的链路层协议。<br>ppp协议提供全双工操作，按照数据传输数据包，设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据。</p>
<ol>
<li>ppp协议具有动态分配ip地址的能力，允许在连接时刻协商ip地址。</li>
<li>ppp支持多种网络协议，比如tcp&#x2F;ip,netbeui等。</li>
<li>没有重传介质，网络开销小，速度快。</li>
<li>ppp可以进行身份验证。</li>
<li>ppp可以用于多种类型的物理介质上，如串口线，电话线，光纤，同样适用于interet接入。</li>
</ol>
<h2 id="hdlc协议"><a href="#hdlc协议" class="headerlink" title="hdlc协议"></a>hdlc协议</h2><p>hdlc协议统一使用帧格式，采用零比特插入法，全双工通信，吞吐率高，在未收到应答帧时，可连续发送信息帧。</p>
<p>采用CRC帧校验序列，可防止漏帧，提高信息传输的可靠性。</p>
<h2 id="中继器-集线器-网桥-交换机"><a href="#中继器-集线器-网桥-交换机" class="headerlink" title="中继器 集线器 网桥 交换机"></a>中继器 集线器 网桥 交换机</h2><p>中继器工作在物理层，用来连接两个速率相同且数据链路层协议相同的网段，功能是消除数字信号在基带传输中由于经过一长段电缆而造成的失真和衰减，使信号的波形和强度达到所需的要求，原理是信号再生。</p>
<p>集线器是工作在物理层，相当于一个多接口中继器，可以将多个结点连接成一个共享式局域网，但任何时候都只能有一个结点通过公共信道发送数据。</p>
<p>网桥工作在数据链路层，可以互联不同的物理层，不同的MAC子层及不同速率的以太网。网桥具有过滤帧及存储转发帧的功能，可以隔离冲突域，不能隔离广播域</p>
<p>交换机工作在数据链路层，相当于一个多端口的网桥，是交换式局域网的核心设备，允许端口之间建立多个并发连接，实现多个结点之间的并发传输。交换机一般工作在全双工方式，有的局域网交换机采用存储转发方式进行转发，也有的交换机采用直通交换方式。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器主要完成两个功能，路由选择和分组转发。</p>
<p>路由选择。按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改编所选择的路由。</p>
<p>分组转发。路由器根据转发表将用户的IP数据报从合适的端口转发出去。路由表是根据路由选择算法得出的，而转发表是从路由表中得到的。转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</p>
<h2 id="距离-向量路由算法"><a href="#距离-向量路由算法" class="headerlink" title="距离-向量路由算法"></a>距离-向量路由算法</h2><p>在距离-路由算法中，所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点，这种路由选择表包含每条路径的目的地和路径的代价。</p>
<p>算有结点都必须参与距离向量交换，以保证路由的有效性和一致性，也就是说，所有的结点都监听从其他结点传来的路由选择更新信息，并根据情况更新路由表。</p>
<p>被通告一条新的路由，该路由在本结点的路由表中不存在，系统加入新路由。</p>
<p>发来的路由有条到达某个目的地的路由，该路由与当前路由相比有较短的距离。此种情况下，就使用经过路由信息的结点的新路由替换路由表中到达那个目的地的现有路由。</p>
<h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p>链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息，他们执行下述两项任务。</p>
<p>首先，主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。然后定期地将链路状态传播给所有其他结点。</p>
<p>距离-向量路由算法与链路状态路由算法比较：在距离-向量路由算法中，每个结点仅与它的直接邻居交谈，它为它的邻居提供从自己到网络中所有结点的最低费用估计。在链路状态路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉他们与它直接相连的链路的费用。距离-向量路由算法有可能遇到路由环路等问题。</p>
<h2 id="路由信息协议-RIP"><a href="#路由信息协议-RIP" class="headerlink" title="路由信息协议(RIP)"></a>路由信息协议(RIP)</h2><p>路由信息协议是一种分布式的基于距离向量的路由选择协议。</p>
<p>路由信息协议允许一条路径最多包含15个路由器，因此距离等于16时，它表示网络不可达。可见路由信息协议只能用于小型网络。距离向量路由可能可能出现环路的情况，规定路径上的最高跳数的目的是为了防止数据报不断循环在环路上，减少网络拥塞的可能性。</p>
<p>路由信息协议默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表。</p>
<h2 id="开放最短路径优先-OSPF"><a href="#开放最短路径优先-OSPF" class="headerlink" title="开放最短路径优先(OSPF)"></a>开放最短路径优先(OSPF)</h2><p>OSPF是使用分布式链路状态路由算法的典型代表，也是内部网关协议IGP的一种。</p>
<p>OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。而RIP仅向自己相邻的几个路由器发送信息。</p>
<p>发送的信息是与本路由器相邻的所有路由器的链路状态，链路状态说明本路由器和哪些路由器相邻及该链路状态。但是RIP发送的信息时本路由器知道的所有信息，是一整个路由表。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞控制和流量控制是有区别的，拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是已知发送端发送数据的速率，以便接收端来得及接收。</p>
<h2 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h2><p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd&#x3D;1，每收到一个对新报文段的确认后，将cwnd加1，用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就会加倍，这样慢开始一直把拥塞窗口cwnd增大到一个规定的慢开始门限，然后改用拥塞避免算法。</p>
<h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>发送端的拥塞窗口cwnd每经过一个往返时延就增加一个最大报文长度的大小，使cwnd按线性规律缓慢增长，当出现一次超时，慢开始门限等于当前cwnd的一半。</p>
<h2 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h2><p>快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测。快重传并非取消重传计时器，而是在某些情况下更早地重传丢失的报文段。当发送方连续收到三个重的ack报文时，直接重传对方尚未收到的报文段，而不必等到那个报文段设置的重传计时器超时。</p>
<h2 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h2><p>发送端收到连续三个冗余ACK时，执行乘法减小算法，把慢开始门限设置为出现拥塞时发送方的cwnd的一半。与慢开始不同的是，它把cwnd的值设置为慢开始改变后的数值，然后开始执行拥塞避免算法使拥塞窗口线性增大。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
